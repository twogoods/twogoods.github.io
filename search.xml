<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[我的2017]]></title>
      <url>http://twogoods.github.io/2018/01/18/2017/</url>
      <content type="html"><![CDATA[<p><img src="http://oepm97cib.bkt.clouddn.com/jiaxing.jpeg" alt=""><br>今天是2017年1月18号<a id="more"></a>，这份总结已经跳票半个月之多了，只怪我最近这段时间有各种各样的事情搞得没有太多心情来总结。这不，总算忙完了，该好好回顾回顾过去的一年了。我们说总结过去一年最好的方式是什么？那就是打开音乐看看过去一年自己拍的照片以及各种动态如微博、朋友圈，当然常见的一个结果就是你发现自己当初发的东西怎么这么傻逼 ╮（﹀_﹀）╭ whatever，我还是想看看这一年那个傻逼程序员都做了什么。</p>
<p>一个普通人，依旧很普通的一年，作为学生，天天食堂、实验室、寝室三点一线，面对显示器的时间估计不比睡觉的时间少多少，有人说多培养培养别的兴趣可偏偏我这个人又懒不愿意去多尝试，我喜欢写程序，对它有兴趣，但愿这份兴趣跟工作年限无关，可以一直持续下去。</p>
<h2 id="「瞎逛」"><a href="#「瞎逛」" class="headerlink" title="「瞎逛」"></a>「瞎逛」</h2><p><img src="http://oepm97cib.bkt.clouddn.com/zjut_classroom.jpeg" alt=""><br>一年也没去过几个地方，倒是攒了一堆上海和杭州两地的火车票…..回了几趟自己一直想回去母校，对杭州还是有很多留恋的东西，毕业回杭州吧！</p>
<p>这一年也难得出了一趟远门，去了次北京，也没太多感受，故宫、天安门、长城也就那样，倒是一年没见的老朋友带我们吃吃喝喝，还挺开心的。</p>
<p>单身狗没有旅行撑死了就是瞎逛。</p>
<h2 id="「读书」"><a href="#「读书」" class="headerlink" title="「读书」"></a>「读书」</h2><p>每年都说希望培养一下看书的习惯，但似乎每年都失败了…..买了两本当时特别有名的书《人类简史》、《未来简史》也只啃完了前一本；买了kindle，里面的《智能时代》、《数学之美》看了几十页，吴军老师的书确实写得非常不错，然而我的阅读记录也还是停在了那几十页。</p>
<p>对于纯技术类的书，买了几本倒是都能全看下来，这毕竟是要吃饭的手艺，这一点上还是能不断学习的。</p>
<h2 id="「编程-amp-工作」"><a href="#「编程-amp-工作」" class="headerlink" title="「编程&amp;工作」"></a>「编程&amp;工作」</h2><p>这一年的前半年在学校上课，后半年在实习，去年希望自己实习能做一些有门槛的事情算是被自己耽误了，实习还是选择了自己一直做的方向。不过也还是蛮幸运的，在饿了么的风控部门实习了大半年，虽然依旧是业务部门，但风控是一个很有意思的业务可以长期发展。这一次的实习也还是学到不少，诸如整个的风控架构，常见的攻击手段等等；在大厂印象最深的就是整个基础设施的完善，自助和自动化做的非常好，DBA、运维、框架都提供了优秀的工具支持。</p>
<p>去年给自己定过一些开源或者工具代码的目标，在个人项目方面这一年也确实有一些小的收获。</p>
<ul>
<li><strong><a href="https://github.com/twogoods/HelloRpc" target="_blank" rel="external">HelloRpc</a></strong>：一个简单的RPC框架。这个项目在去年春节期间就计划着，开学后动手慢慢完成，并不断完善。虽然在完成这个项目之前我大概了解了业界比较好的几个开源框架，但终究是没有实战过，导致一些地方考虑不周，在后来的实习中接触到了饿了么内部的RPC框架，反倒是给了我很多的提示。</li>
<li><strong><a href="https://github.com/twogoods/TgDao" target="_blank" rel="external">TgDao</a></strong>：一个基于MyBatis的SQL生成器。这个项目我倒是犹豫了好久才开始动手。这个工具核心的原理是Java的编译器注解技术，我在一次很偶然的机会了解到它，当时就觉得是个神器可以做非常多有意思的东西。至于做SQL生成器的这个idea其实是我在另一个开源项目中看到的，但是它的限制比较多，我觉得不够自由，SQL的表达能力还是有限。但是我没有马上动手，因为当时在学校，没有大量写SQL的需求，后来去了实习发现用的是MyBatis Generator，终于不能忍开始动手写了…..这个工具已经在公司的一个项目里用起来了，也成了我第一个star上两位数的项目，挺有成就感的。</li>
</ul>
<p>除了这些，这一年也在捯饬Netty、Reactive、Vert.x，这些东西对于传统的Java程序员还是有一些学习门槛，虽然也试着总结过一篇文章《<a href="http://twogoods.github.io/2017/09/09/async/">异步编程杂谈</a>》但觉得还是半懂不懂的，新的一年争取啃下来。</p>
<h2 id="「新年计划」"><a href="#「新年计划」" class="headerlink" title="「新年计划」"></a>「新年计划」</h2><p>老规矩，说计划之前不得先看看去年的计划完成了没有啊？看了一眼去年的计划，读书、培养新的兴趣方面确实做得不够，在提升技能方面倒还是中规中矩。</p>
<ul>
<li><strong>编程</strong>：其实去年做得还可以，倒希望这个能成为一个长期的目标，每年能有一两个有意思的小工具产出。有的时候和程序员朋友聊天，有的人就说程序员没前途的，天天加班……其实工作中的业务代码它确实是没什么意思的，就是一份工作而已，要保持对这个工作的兴趣除了是出于自己喜欢来做这一行以外，确实需要一些业余项目来给自己找乐子找成就感。但愿我的这份热情能一直保持下去。</li>
<li><strong>毕业</strong>：是的，我今年要毕业了，虽然真正拿到毕业证是明年了。其实对于读研究生这个决定本身我是后悔的，但这三年我有大量自己支配的时间，我觉得自己利用的还不错；反过来一想我多花了三年时间自己学习还能拿到一张研究生文凭，貌似也还行。希望能顺利毕业，这是今年最大的愿望了。</li>
<li><strong>其他</strong>：不知道还有什么就写了个其他，读书？新的兴趣拓展眼界？感觉还是困难，谁让我是个傻逼程序员呢，我尽量吧。出个国玩一玩？嗯，这个可以考虑；理财？嗯，在学习。</li>
</ul>
<h2 id="「尾巴」"><a href="#「尾巴」" class="headerlink" title="「尾巴」"></a>「尾巴」</h2><p>看了看前面自己写的，果然还是总结编程的内容篇幅最多，嗯，我还是典型的程序员，跳不出去。这一年好几个以前的朋友都胖了，我倒控制的还行，希望大家都身体健康；这一年有的人结婚了，有的人当了爸爸，我却依然年轻依然单身；这一年好多以前的好朋友都没怎么碰面，无论你们在哪里，希望你们一切都好。</p>
<p>期待2018！祝福自己！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[异步编程杂谈]]></title>
      <url>http://twogoods.github.io/2017/09/09/async/</url>
      <content type="html"><![CDATA[<p>响应式编程、RxJava、Vert.x、异步编程、事件驱动、NodeJs、Callback、高性能，一堆很诱惑人的名词，折腾了一段时间，总结一些内容也提出一些疑问。<a id="more"></a></p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>关于异步和同步，阻塞与非阻塞，给一个在IO模型里的定义：</p>
<blockquote>
<p>阻塞与非阻塞关注的是线程的状态，IO操作会不会把当前线程挂起。<br>同步和异步关注的是消息通知机制，调用者需不需要关注这个数据返回。</p>
</blockquote>
<p>关于IO模型这里有<a href="http://twogoods.github.io/2017/04/27/IO-Model/">一篇</a>，它在说的操作系统里的IO模型。它似乎跟我们日常开发过程中的一些地方有区别，如Java的这段代码，它非阻塞吧，它是异步吗？应该也是吧，开了异步线程去执行了啊。但是再去套一下上面的异步与非阻塞的定义，似乎说它是同步非阻塞才对啊，在这里我们调用者是<strong>关注</strong>这个结果的嘛。<br><code>executor.submit(()-&gt;sql.query(&quot;select * from table&quot;));</code></p>
<p>说到异步非阻塞，总要提NodeJs，它是怎么实现异步IO的呢？下面摘一段《深入浅出NodeJs里的解释》：</p>
<blockquote>
<p>通过让部分线程进行阻塞IO或者非阻塞IO加轮询技术(NIO,epoll)来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将IO得到的数据进行传递，这就轻松实现了异步IO(尽管它是模拟的)</p>
</blockquote>
<p>这段话似乎和我们上面的代码例子很像哦，它通过用异步线程的方式来执行IO操作，就像这段话最后的括号所说，尽管它是模拟的(这里是跟操作系统提供的AIO做比较)。<br>这么看来实现异步也不难嘛，造一个线程池，把IO操作放进独立的线程里去执行，这就是一个非常朴素的异步思想啊。</p>
<h2 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h2><p>Vert.x 是Java语言下的一个异步框架，跟NodeJs非常非常的像，我们简单了解一下它是这么实现的。如下数据库查询操作，和Nodejs的写法几乎一样吧！</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.getConnection</span>(res -&gt; &#123;</span><br><span class="line">      SQLConnection connection = res<span class="selector-class">.result</span>();</span><br><span class="line">      <span class="selector-tag">connection</span><span class="selector-class">.query</span>(<span class="string">"SELECT count(1) FROM T_User"</span>, res2 -&gt; &#123;</span><br><span class="line">          <span class="selector-tag">connection</span><span class="selector-class">.query</span>(<span class="string">"SELECT count(1) FROM T_Book"</span>, res3 -&gt; &#123;</span><br><span class="line">              System<span class="selector-class">.out</span><span class="selector-class">.println</span>(res2.result().getRows() + <span class="string">"--"</span> + res3.result().getRows());</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>我们只看<code>getConnection</code>操作，其他都类似。<code>getConnection</code>传入一个回调函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SQLClient getConnection(Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt; handler) &#123;</span><br><span class="line">       Context ctx = <span class="keyword">this</span>.vertx.getOrCreateContext();</span><br><span class="line">       <span class="comment">// 在线程池中取线程执行真正的拿数据库连接的工作</span></span><br><span class="line">       <span class="keyword">this</span>.exec.execute(() -&gt; &#123;</span><br><span class="line">           Future res = Future.future();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Connection conn = <span class="keyword">this</span>.ds.getConnection();</span><br><span class="line">               Object execMetric = <span class="literal">null</span>;</span><br><span class="line">               SQLConnection sconn = new JDBCConnectionImpl(ctx, <span class="keyword">this</span>.helper, conn, metrics, execMetric, <span class="keyword">this</span>.rowStreamFetchSize);</span><br><span class="line">               res.complete(sconn);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SQLException var9) &#123;</span><br><span class="line">               res.fail(var9);</span><br><span class="line">           &#125;</span><br><span class="line">           ctx.runOnContext((v) -&gt; &#123;</span><br><span class="line">               <span class="comment">//取到数据库连接执行回调函数，</span></span><br><span class="line">               <span class="comment">//这个回调函数又会在另一个线程里执行，这个线程是eventloop线程</span></span><br><span class="line">               res.setHandler(handler);           </span><br><span class="line">            &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，如果让你封装一个异步操作的API，相信你也能很快做出来。Ok，简单了解了实现，那么一个有意思的问题来了。上面的源代码中，获得数据库连接是在通过<code>this.exec.execute</code>在一个线程池中执行的，那回调函数为什么在<code>ctx.runOnContext</code>事件循环线程中执行，继续使用<code>this.exec.execute</code>执行不行吗？其实在当前的这个场景下看起来是可以的，更大的原因是我们有一系列的回调函数，我们都会让回调函数在EventLoop中执行，这样可以很方便的重新回到事件循环中去。可以<a href="https://stackoverflow.com/questions/46030041/some-questions-about-thread-pool-in-vert-x/46030664#46030664" target="_blank" rel="external">参考stackoverflow</a>。</p>
<p>再看一下NodeJs异步的实现方式，Vert.x 和它是不是几乎是一样的。<br><img src="http://oepm97cib.bkt.clouddn.com/node.jpeg" alt="Node异步IO实现"></p>
<h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><p>在说callback之前要先说说另一个话题，为什么利用异步非阻塞IO的NodeJs一出来就标榜高性能，到底高性能在哪了？你会不会觉得我这个问题问的莫名其妙，异步非阻塞的我一个操作调用了就可以立马去做下一个操作了不需要等待，当然性能高啦！前面这句话该怎么理解呢？我用自己的思维方式尝试着理解了一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//一个耗时15ms,一个10ms</span><br><span class="line">data = sql.query("<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span><span class="string">");</span><br><span class="line">count= sql.query("</span><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span><span class="string">");</span><br><span class="line">//time=15+10</span><br><span class="line"></span><br><span class="line">future=executor.submit(()-&gt;sql.query("</span><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span><span class="string">"));</span><br><span class="line">future2=executor.submit(()-&gt;sql.query("</span><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span><span class="string">"));</span><br><span class="line">//time=max(15,10)</span></span><br></pre></td></tr></table></figure>
<p>这样抽象过后，从本质上来说这是并行带来的好处。我们把关注点放在<code>sql.query</code>这个IO操作上，如果这个IO是阻塞的，那这里我们只享受到了两个query并行带来的好处，并没有享受到非阻塞IO带来的好处。试想一下，我们开了两个线程，可是这两个线程在执行query操作的时候都阻塞了，经历了线程被挂起再被唤醒的过程，如果系统大量的都是这种操作，那么线程切换的开销也是巨大的。所以总结一下，一个是多个操作可以并行所带来的优势，一个还是非阻塞IO带来的硬件资源充分利用的优势。(以上，欢迎指出错误。)</p>
<p>当我知道了这些，似乎获得了魔法，急着跑回到Java世界想用异步改造我的代码，可结果是….大量的业务逻辑都是前后依赖，没什么并行度，强行上异步没得到啥好处的同时引入了复杂度。我们说callback是异步世界写同步代码所呈现的形式，如果你的代码里类似的callback多，那说明这个操作内部并行度本身就不高，并行带来的好处不大。现在Java里大大小小的框架大都没有异步API，没有非阻塞IO，改造往往是从入门到放弃。延伸一下，<a href="https://www.zhihu.com/question/23084473" target="_blank" rel="external">为什么JDBC操作不用NIO?</a></p>
<p>好，现在我们再聊callback，异步编程的风格将函数的业务重点从放回值转移到了回调函数中。依然用Vert.x的那段代码，这里callback套了三层。为什么会嵌套？由于各个操作会依赖于前一个操作，不可避免的就嵌套了，因此在异步为主导的编程框架里，就容易写成callback一层一层嵌套的形式。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.getConnection</span>(res -&gt; &#123;</span><br><span class="line">       SQLConnection connection = res<span class="selector-class">.result</span>();</span><br><span class="line">       <span class="selector-tag">connection</span><span class="selector-class">.query</span>(<span class="string">"SELECT count(1) FROM T_User"</span>, res2 -&gt; &#123;</span><br><span class="line">           <span class="selector-tag">connection</span><span class="selector-class">.query</span>(<span class="string">"SELECT count(1) FROM T_Book"</span>, res3 -&gt; &#123;</span><br><span class="line">               System<span class="selector-class">.out</span><span class="selector-class">.println</span>(res2.result().getRows() + <span class="string">"--"</span> + res3.result().getRows());</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>在一般的Java项目里我们会用同步的方式会这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLConnection connection=client.getConnection();</span><br><span class="line">data1=connection.query("<span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> T_User<span class="string">");</span><br><span class="line">data2=connection.query("</span><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> T_Book<span class="string">");</span></span><br></pre></td></tr></table></figure>
<p>有了比较，我们可以更一针见血的说，callback的产生是因为要在异步为主导的世界里写同步代码而不得不采取的做法。当然啦，callback hell 很难受，NodeJs提供了多个API来解决这个问题，我不太熟这个所以不打算深入介绍，但是上面这个Java写的例子我们有必要解决一下。</p>
<h2 id="响应式编程和异步编程"><a href="#响应式编程和异步编程" class="headerlink" title="响应式编程和异步编程"></a>响应式编程和异步编程</h2><p>响应式编程的两个特点是异步与流，它帮助你用最简便的方式实现异步，并且它将一切看作流，从这个流出发，过滤、组合、变换。即将到来的JDK9也会实现响应式编程的规范带来<a href="https://community.oracle.com/docs/DOC-1006738" target="_blank" rel="external">Flow API</a>，随JDK9一起到来的Spring5正式版中也将引入对响应式web编程的<a href="https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/reactive-web.html#webflux" target="_blank" rel="external">支持</a>。如果你是一个新手，建议参考这篇关于<a href="http://blog.csdn.net/womendeaiwoming/article/details/46506017" target="_blank" rel="external">响应式编程介绍</a>。</p>
<p>我们利用RxJava 尝试着解决一下callabck的问题。还是SQL操作的代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lient</span><span class="selector-class">.getConnection</span>(res -&gt; &#123;</span><br><span class="line">       SQLConnection connection = res<span class="selector-class">.result</span>();</span><br><span class="line">       <span class="selector-tag">connection</span><span class="selector-class">.query</span>(<span class="string">"SELECT count(1) FROM T_User"</span>, res2 -&gt; &#123;</span><br><span class="line">           <span class="selector-tag">connection</span><span class="selector-class">.query</span>(<span class="string">"SELECT count(1) FROM T_Book"</span>, res3 -&gt; &#123;</span><br><span class="line">               System<span class="selector-class">.out</span><span class="selector-class">.println</span>(res2.result().getRows() + <span class="string">"--"</span> + res3.result().getRows());</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>RxJava:</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">O<span class="function"><span class="title">bservable</span>&lt;SQLConnection&gt; conObservable = Observable.create(emitter -&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">client</span>.getConnection(res -&gt;</span> &#123;</span><br><span class="line">                emitter.onNext(res.result());</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">O<span class="function"><span class="title">bservable</span>&lt;String&gt; data1 = conObservable.concatMap(connection -&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">return</span> Observable.create(observableEmitter -&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">connection</span>.query("SELECT count(1) FROM T_User", res2 -&gt;</span> &#123;</span><br><span class="line">          observableEmitter.onNext(res2.result().getRows().toString());</span><br><span class="line">          observableEmitter.onComplete();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">O<span class="function"><span class="title">bservable</span>&lt;String&gt; data2 = conObservable.concatMap(connection -&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">return</span> Observable.create(observableEmitter -&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">connection</span>.query("SELECT count(2) FROM T_User", res2 -&gt;</span> &#123;</span><br><span class="line">          observableEmitter.onNext(res2.result().getRows().toString());</span><br><span class="line">          observableEmitter.onComplete();</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> O<span class="function"><span class="title">bservable</span>.zip(data1, data2, (d1, d2) -&gt;</span> d1 + d2).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>Java8 CompletableFuture 也同样可以实现：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;SQLConnection&gt; promise = new CompletableFuture&lt;&gt;();</span><br><span class="line"><span class="function"><span class="title">client</span>.getConnection(res -&gt;</span> promise.complete(res.result()));</span><br><span class="line"><span class="function"><span class="title">promise</span>.thenCompose(conn -&gt;</span> &#123;</span><br><span class="line">  CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="title">conn</span>.query("SELECT count(1) FROM T_User", <span class="keyword">data</span> -&gt;</span> &#123;</span><br><span class="line">      future.complete(<span class="keyword">data</span>.result().getRows().toString());</span><br><span class="line">  &#125;);</span><br><span class="line">  return future;</span><br><span class="line">&#125;).<span class="function"><span class="title">thenCompose</span>(s -&gt;</span> &#123;</span><br><span class="line">          CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class="line">          <span class="function"><span class="title">promise</span>.thenAccept(conn -&gt;</span> &#123;</span><br><span class="line">              <span class="function"><span class="title">conn</span>.query("SELECT count(1) FROM T_User", <span class="keyword">data</span> -&gt;</span> &#123;</span><br><span class="line">                  future.complete(<span class="keyword">data</span>.result().getRows().toString() + <span class="string">"  "</span> + s);</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">          return future;</span><br><span class="line">      &#125;</span><br><span class="line">).thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>
<p>虽然解决了层层嵌套的问题，但代码量实在是有点多，没办法，这就是Java，当然如果你有更好的办法请告诉我。</p>
<p>异步编程也会带来一些不好处理的地方，典型的一个就是异常处理，异步执行的代码出异常了如何通知到调用的线程。NodeJs是通过在回调函数中传入error来处理异常，类似<code>db.query(&#39;select * from table , function(err,result){}</code>。Java编程中虽然RxJava还是封装了不错的异常处理机制，但比起同步模式下的编程，异步代码中的异常处理会是一个痛点。</p>
<p>欢迎指正。</p>
<p>参考：<br><a href="http://emacoo.cn/backend/reactive-overview/" target="_blank" rel="external">http://emacoo.cn/backend/reactive-overview/</a><br><a href="http://www.streamis.me" target="_blank" rel="external">http://www.streamis.me</a><br><a href="https://stackoverflow.com/questions/22412960/vert-x-and-bio-threading?rq=1" target="_blank" rel="external">https://stackoverflow.com/questions/22412960/vert-x-and-bio-threading?rq=1</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[netty源码简读]]></title>
      <url>http://twogoods.github.io/2017/05/24/netty/</url>
      <content type="html"><![CDATA[<p>Java里著名框架的源码往往不容易读，他们在功能上大而全，把多态用到极致，又有很多的性能优化;相应的由于著名所以网上的资源也非常多，慢慢读总还是能体会到整个框架的设计和思路。配合着网上的博客，书籍和源代码，花了三天时间阅读，有了一定的收获，做一下笔记。<br>看netty之前回顾一下Java NIO，列一下使用Java API开发NIO所需要的几个步骤<a id="more"></a></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">selector = Selector.<span class="keyword">open</span>();<span class="comment">//打开一个多路复用器</span></span><br><span class="line">servChannel = ServerSocketChannel.<span class="keyword">open</span>();<span class="comment">//打开一个ServerSocketChannel</span></span><br><span class="line">servChannel.configureBlocking(false);<span class="comment">//设置异步</span></span><br><span class="line">servChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port), <span class="number">1024</span>);<span class="comment">//ServerSocketChannel绑定到地址</span></span><br><span class="line"><span class="comment">//将ServerSocketChannel注册到selector上</span></span><br><span class="line">SelectionKey <span class="built_in">key</span> = servChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">public void <span class="keyword">run</span>() &#123;</span><br><span class="line">    <span class="comment">//事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">stop</span>) &#123;</span><br><span class="line">            selector.<span class="built_in">select</span>();<span class="comment">//在没有channel可用时一直阻塞</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<span class="comment">//获取可用的channel</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();</span><br><span class="line">            SelectionKey <span class="built_in">key</span> = <span class="built_in">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="built_in">key</span> = it.next();</span><br><span class="line">                it.remove();</span><br><span class="line">                handle(<span class="built_in">key</span>);<span class="comment">//每个channel具体的处理逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在<code>run()</code>方法里开启了我们的Reactor线程，不断的获取注册在selector上的有新事件的channel，这里我们只用一个线程就处理了所有的连接，远比BIO下一个连接一个线程优秀。在循环代码里我们看到channel具体的处理逻辑是一个一个串行执行的，但是channel间没有任何联系，这个过程我们是可以利用线程池让多个channel并行处理来进一步提高性能。讲到线程我们可以联系一下Reactor的线程模型。</p>
<p>Reactor单线程模型:一个Reactor线程处理所有的连接的接入和读写操作，我们上面给出的代码例子就是这个模型。<br><img src="http://oepm97cib.bkt.clouddn.com/reactor1.png" alt="Reactor单线程模型"></p>
<p>Reactor多线程模型:由于单线程模型在面对大并发的情况下就显得力不从心了，所以我们在这里引入了线程池，利用多个线程来处理。具体就是我们只用一组线程来处理读写请求，毕竟读写是网络编程里最重要的两个操作，性能好不好，能不能抗住大并发很大的关键在这里；然后我们利用一个线程专门负责处理客户端的连接操作，注意这里只用了一个线程，连接建立起来之后，将channel注册到线程池中的某一个线程的多路复用器上。好，我们一句话总结：前面一个Reacotr线程处理所有的连接建立操作，确认连接后将Channel注册到后面的Reactor线程池的某个线程上，这样大量的读写操作被平均分配到了多个线程上处理，提高了吞吐量。<br><img src="http://oepm97cib.bkt.clouddn.com/reactor2.png" alt="Reactor多线程模型"></p>
<p>主从Reactor多线程模型：在多线程模型中，我们只用了一个线程来处理客户端的登陆、握手和安全认证，在一些特殊场景下还是回存在一些性能问题，于是进一步改造把acceptor的线程也改造成线程池，让多个线程来处理客户端接入。<br><img src="http://oepm97cib.bkt.clouddn.com/reactor3.png" alt="主从Reactor多线程模型"></p>
<p>我们把Reactor线程模型简单介绍了一下，这是事件循环的模型。我们上面提出的问题是，某个事件循环里<code>selector.selectedKeys()</code>这个操作hi返回一系列可用的channel,这些channel的处理可以使用线程池来并发执行吗？这个问题在上面的三个Reactor线程模型中还暂时得不到答案，我们在源码中看一看。<br>由于netty是对Java NIO的封装所以一上来我的思路是把使用java API写的NIO程序中的每一个步骤看看是在netty的哪个地方实现的，这样一圈下来就能基本搞明白netty的流程。我们重点看Reactor线程模型和事件机制，netty的事件是在一条pipeline中传播的，每个channel都会有一条pipeline，pipeline里第一个是head,最后一个是tail,中间是一系列自定义的处理器，如果一个处理器可以处理，那么事件传递到这里结束，否则继续传递给下一个handle。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">     .channel(NioServerSocketChannel.class)</span><br><span class="line">     .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">     .<span class="keyword">handler</span>(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">     .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             ChannelPipeline p = ch.pipeline();</span><br><span class="line">             <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">             &#125;</span><br><span class="line">             p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">    ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>
<p>以上是netty的最基本的使用方式，首先我们创建了两个<code>EventLoopGroup</code>,对应于Reactor线程模型，第一个是Acceptor用于连接的，第二个是负责读写操作的线程池。深入到<code>EventLoopGroup</code>的构造器：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span><br><span class="line">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只保留了核心的代码</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//注意newDefaultThreadFactory只是一个一个的创建线程,这个默认的执行器本质上不是线程池，</span></span><br><span class="line">        <span class="comment">//因为事件循环基本上就是死循环，不太会有线程复用的需求</span></span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的children就是EventLoop，一个group里有多个EventLoop，我们说它是线程池</span></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        children[i] = newChild(executor, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//EventLoop的选择策略.默认是一个个轮询</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看看newChild方法，</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NioEventLoop的构造函数</span></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;<span class="comment">//不同操作系统，多路复用器的实现不一样，有不同提供者</span></span><br><span class="line">    <span class="comment">//这里我们看到了第一个步骤，每个Reactor线程都有一个Selector并在这里被打开</span></span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看，<code>ServerBootstrap</code>的构造,利用构建器模式设置它的属性</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//group方法设置两个线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个acceptor线程组传入父类</span></span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置handle和childhandle,两个的区别后面有介绍</span></span><br><span class="line"><span class="keyword">handler</span>(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()）</span><br></pre></td></tr></table></figure>
<p>现在我们关注<code>ChannelFuture f = b.bind(PORT).sync()</code>的<code>bind</code>方法</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function">ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化,注册</span></span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        promise.registered();</span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="function">ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过设置代码里 channel(NioServerSocketChannel.class) 反射通过构造器创建channel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);<span class="comment">//初始化</span></span><br><span class="line">        <span class="comment">//取到的这个group是初始化时的第一个group线程组,在其之上注册</span></span><br><span class="line">        <span class="comment">//register是在SingleThreadEventLoop里执行</span></span><br><span class="line">        ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面反射创建对象，在NioServerSocketChannel的构造器里，我们看到打开一个ServerSocketChannel</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">return</span> provider.<span class="title">openServerSocketChannel</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//看看init(channel)，这是个多态方法，由于设置的是server端，实现在ServerBootstrap里</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置ServerBootstrap创建时属性</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">        <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">            setChannelOptions(channel, options, logger);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">        <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : attrs.entrySet()) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pipeline会在channel创建的时候也默认创建</span></span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;<span class="comment">//是.group()第二个参数设置的workerGroup</span></span><br><span class="line">        <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;<span class="comment">//childHandler</span></span><br><span class="line">        <span class="comment">//往pipeline里添加一系列的handler，这里只是ChannelInitializer，初始化完真正添加到pipeline里</span></span><br><span class="line">        <span class="comment">//ChannelInitializer的initChannel方法在channel被注册的时候调用,这个时候这个handler被加入pipeline</span></span><br><span class="line">        ChannelHandler test = <span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler <span class="keyword">handler</span> = config.<span class="keyword">handler</span>();<span class="comment">//外面的handler直接加进去</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">handler</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">handler</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span><br><span class="line">                    这里的eventLoop是channel注册时的那个eventloop(每个eventloop里都有一个selector)</span><br><span class="line">                    这个execute 并没有立马被执行,这个Runnable被扔到了task队列里</span><br><span class="line">                  */</span></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">/**</span><br><span class="line">                         * ServerBootstrapAcceptor是一个acceptor</span><br><span class="line">                         * 当前的这条pipeline是serversocketchannel的,serversocketchannel主要是accept一个连接用的,</span><br><span class="line">                         * 它不处理childhandler,而且这个serversocketchannel对应的是bosseventloop,这个eventloop只处理新连接的接入</span><br><span class="line">                         *</span><br><span class="line">                         * 在新的连接接入的时候调用这条pipeline(serversocketchannel的pipeline),</span><br><span class="line">                         * 在这条pipeline里我们完成了serversocket.accept(),建立了连接得到的socketchannel,将他注册到了workeventloop上(这个eventloop关注读写操作)</span><br><span class="line">                         * 我们知道每个channel都会有一条pipeline,在ServerBootstrapAcceptor里我们给刚连接的这个socketchannel里的pipeline添加了childhandler来处理用户自定义的读写请求</span><br><span class="line">                         * (连接建立起来的这个channel完成真正的读写,代码中我们也是在childhandler里添加处理读写的handler,)</span><br><span class="line">                         */</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.addLast(test);<span class="comment">//只是添加了一个ChannelInitializer,具体的handler这个时候还没有添加进去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//ServerBootstrapAcceptor这个handler会吧建立好链路的channel注册到workeventloop上，具体实现在其channelRead方法里</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">       <span class="comment">//为客户端新连接的这个channel设置pipeline,这里childHandler就是我们会自己定义的那些处理读写的handler</span></span><br><span class="line">       child.pipeline().addLast(childHandler);</span><br><span class="line">      <span class="comment">//给这个channel注册到复用器,注意这里是注册到childGroup,即第二个workeventloop上</span></span><br><span class="line">      childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                  forceClose(child, future.cause());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">pipeline本身是一个双向链表，通过addLast等方法添加handle</span><br><span class="line">最终serversocketchannel的pipelinede 组成是这样的：headhandler--LoggerHandler--ServerBootstrapAcceptor--tailHandler</span><br><span class="line">每一个建立起来的channel中的pipelinede 组成是这样的：headhandler--childrenhandler--tailHandler</span><br></pre></td></tr></table></figure>
<p>Channel的init好后看看<code>register()</code></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">      doRegister();<span class="comment">//执行注册</span></span><br><span class="line">      neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">      registered = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//这里把ChannelInitializer里的init方法执行,添加handler进去</span></span><br><span class="line">      pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">      safeSetSuccess(promise);</span><br><span class="line">      pipeline.fireChannelRegistered();<span class="comment">//注册好，发送事件</span></span><br><span class="line">      <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">              pipeline.fireChannelActive();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">              beginRead();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//真正的执行注册</span></span><br><span class="line">           <span class="comment">//javaChannel() 取出构造器执行时 通过 SelectorProvider的openXXX方法新建的SelectableChannel</span></span><br><span class="line">           <span class="comment">//第三个参数是注册携带的附件,selectionKey中会携带回来</span></span><br><span class="line">           selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">               eventLoop().selectNow();</span><br><span class="line">               selected = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>netty在何处开启事件循环呢？事件循环在NioEvevtLoop的<code>run()</code>方法里，沿着调用链往上找我们找到了<code>SingleThreadEventExecutor</code>的<code>execute</code>方法</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> execute(Runnable <span class="keyword">task</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">            addTask(<span class="keyword">task</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//任何一个EventLoop.execute()都会启动这个selector的主循环</span></span><br><span class="line">            startThread();</span><br><span class="line">            addTask(<span class="keyword">task</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> startThread() &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">            <span class="comment">//判断是否已经启动过了，事件循环的线程只会启动一次</span></span><br><span class="line">            <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>事件循环开始，我们看到<code>run()</code>方法里的<code>processSelectedKeys()</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysPlain</span>(<span class="params">Set&lt;SelectionKey&gt; selectedKeys</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();</span><br><span class="line">       <span class="comment">//这里是for循环，多个SelectionKey可用时，是串行执行</span></span><br><span class="line">       <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">           final SelectionKey k = i.next();</span><br><span class="line">           final Object a = k.attachment();</span><br><span class="line">           i.remove();</span><br><span class="line">           <span class="keyword">if</span> (a instanceof AbstractNioChannel) &#123;</span><br><span class="line">               processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">               NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">               processSelectedKey(k, task);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!i.hasNext()) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">               selectAgain();</span><br><span class="line">               selectedKeys = selector.selectedKeys();å</span><br><span class="line">               <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   i = selectedKeys.iterator();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//具体的处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span>(<span class="params">SelectionKey k, AbstractNioChannel ch</span>) </span>&#123;</span><br><span class="line">       final AbstractNioChannel.NioUnsafe <span class="keyword">unsafe</span> = ch.<span class="keyword">unsafe</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">           <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">               ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">               k.interestOps(ops);</span><br><span class="line">               <span class="keyword">unsafe</span>.finishConnect();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">               ch.<span class="keyword">unsafe</span>().forceFlush();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">/**</span><br><span class="line">                *此处监听读或者连接操作,这里的read()方法是个多态方法,有两个实现,niomessageunsafe 是 nioserversocketchannel 继承链上的,这里的read 变成了accept连接操作</span><br><span class="line">                * niobyteunsafe 是niosocketchannel 继承链上的,所以这里确实就是读取操作</span><br><span class="line">               */</span></span><br><span class="line">               <span class="keyword">unsafe</span>.read();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">           <span class="keyword">unsafe</span>.close(<span class="keyword">unsafe</span>.voidPromise());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//niomessageunsafe的read()方法里会执行`doReadMessages()`方法，这个方法由NioServerSocketChannel实现</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span>(<span class="params">List&lt;Object&gt; buf</span>) throws Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 接受新的客户端连接</span></span><br><span class="line">       SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">               buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ch.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">               logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们在源码里找到了在Java NIO里要做的每一步操作，在代码中也看到了创建的两个<code>EventLoopGroup</code>的作用：一个接受连接，一个处理读写。最上面我提过一个想法，就是一个<code>selector</code>得到多个<code>selectedKeys</code>时，利用线程来并发处理，在netty源码里我们看到了，这些<code>selectedKeys</code>依旧是for循环的方法串行执行的，为什么这样呢？<br>这个问题解释起来其实很简单，先看一个简单的例子，你只有一个核心的机器，有5个任务要跑，要求最快完成这5个任务，你是在一个线程上顺序跑这5个任务还是5个线程一起跑呢？当然是顺序跑啦，只有一个核，多线程微观上还是串行执行的嘛，而且还要引入线程切换的开销，所以说假设你的任务非常消耗CPU, 那么现在每个CPU都被占满了, 你再增加线程个数, 只能降低系统的效率, 因为线程还需要切换。所以我们在很多线程池的默认设置中看到N,N+1的线程数设置。我们的<code>NIOEventLoopGroup</code>默认是线程数是CPU数*2，这些eventloop全部开启，我们的cpu其实已经在这些事件循环上跑满了，再开线程去跑具体的用户业务逻辑并不是好的做法（线程数默认是2N，这么做是因为eventloop是会阻塞的，这个时候cpu空闲了有能力处理其他的线程了，所以这里我们的线程数比核心数多，线程数=CPU核心数/(1-阻塞系数)）。</p>
<p>这里简单的介绍了一下netty的源码，看的时间短设计的内容也有限，对于netty内部还有很多东西值得去琢磨。列一下过程中参考的资料：《netty权威指南》，《Netty5.0架构剖析和源码解读》。<br>以前主要的工作就是在Spring上堆业务代码，都是在http之上，netty不是因为自己要写一个rpc框架还真的就用不到，也就对网络编程知之甚少。最近看到的一些内容给我开了一扇门，线程，协程，事件驱动，异步这些都是高性能程序常常出现的名词，也会涉及很多操作系统层次的东西，程序员还是应该往下走，在上面堆业务还是进步太慢。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CAS中的遇到的一些问题]]></title>
      <url>http://twogoods.github.io/2017/05/14/CAS/</url>
      <content type="html"><![CDATA[<p>看并发看到了无锁的CAS，都说无锁没有锁竞争带来的开销，也没有线程间频繁调度的开销，比基于锁的方式有更好的性能。小白看了很激动，这么好的工具赶紧用起来。于是想试着把以前的一段并发代码改一改。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenchController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] lockObj;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt;[] locks;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        lockObj = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lockObj.length; i++) &#123;</span><br><span class="line">            lockObj[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        locks = <span class="keyword">new</span> AtomicReference[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.length; i++) &#123;</span><br><span class="line">            locks[i] = <span class="keyword">new</span> AtomicReference&lt;Integer&gt;(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"a/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">a</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> index = id % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">long</span> inner = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockObj[index]) &#123;</span><br><span class="line">            inner = test();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> result = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"all: "</span> + result + <span class="string">" inner: "</span> + inner);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"b/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">b</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        id = id % <span class="number">100</span>;</span><br><span class="line">        AtomicReference&lt;Integer&gt; lock = locks[id];</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!lock.compareAndSet(<span class="keyword">null</span>, id)) &#123;</span><br><span class="line">            b = <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> inner = test();</span><br><span class="line">        <span class="keyword">boolean</span> flag = lock.compareAndSet(id, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> result = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"all: "</span> + result + <span class="string">" inner: "</span> + inner + <span class="string">" flag:"</span> + flag);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> innerstart = System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis() - innerstart);</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - innerstart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的场景很简单，多个用户可能对一个id的订单做操作，而业务上只能有一个用户操作成功，当初实现的时候用的<code>a()</code>方法，基于无锁的思路我添加了b。用Jmeter每秒发20个同id的请求，结果很意外，有锁代码明显好于无锁的代码。当然这绝不是一个靠谱的性能测试办法，但这也抛给我一个问题，无锁不是号称性能很好嘛，为什么这里这么差？再往下走我发现了一个怪异的问题，在使用无锁的情况下我特地独立出来的<code>test()</code>里打印的睡眠时间和200毫秒相差巨大…这里非常的怪异，sleep有几个毫秒的误差是正常的，然而实际的误差有的实在太大。花了很长时间，问了问别人，我发现了这其中的一些问题：在我的机器上每秒20个线程请求无锁代码，我的cpu被占满了，再仔细想一想就会发现CAS操作虽然免去了线程调度的开销，然而不能忽略它不断尝试直到成功的那段死循环对CPU负载的影响，CAS下的所有线程都是活跃线程（这里可以联系一下JVM锁优化里的自旋锁，线程没拿到锁不会马上挂起，而是自旋等待一会儿，如果这时拿到锁就省去了线程调度的开销）。回到这个例子当中，200毫秒的睡眠不是一个短的时间，每秒20个请求远远超出了处理能力，有大量的线程占用着“无意义”的CPU计算资源。</p>
<p>后来我又看到了这篇讨论AtomicInteger的<a href="http://ifeve.com/enhanced-cas-in-jdk8/" target="_blank" rel="external">文章</a>,文中显式的调用<code>compareAndSet()</code>方法，结果是不如<code>synchronized</code>来的好。当然我已经不止一次被告知在测试细微性能差别的时候Main方法往往是不靠谱的,那应该怎么测试呢？jmh。</p>
<h2 id="jmh"><a href="#jmh" class="headerlink" title="jmh"></a>jmh</h2><p>编写测试代码，使用注解，然后jmh完成剩下一切。<br>Mode:</p>
<ul>
<li>Mode.Throughput 指定多少次迭代，计算总时间 op/s</li>
<li>Mode.AverageTime 方法执行的平均时间 op/s</li>
<li>Mode.SampleTime 不测量总时间，测量某一部分调用的时间，所以结果中你能看到 p0.5，p0.9</li>
<li>Mode.SingleShotTime 每次迭代只执行一次</li>
</ul>
<p>state:</p>
<ul>
<li>Scope.Thread:线程私有</li>
<li>Scope.Benchmark：线程共享</li>
</ul>
<p>Dead-Code Elimination (DCE)</p>
<pre><code>@Benchmark
public double measureWrong() {
    Math.log(x1);//注意编译器优化，这一行无意义，会被优化掉，使用后面两种方式
    return Math.log(x2);
}
@Benchmark
public double measureRight_1() {
    return Math.log(x1) + Math.log(x2);
}
@Benchmark
public void measureRight_2(Blackhole bh) {
    bh.consume(Math.log(x1));
    bh.consume(Math.log(x2));
}
--------------------------------------------
private double x = Math.PI;
private final double wrongX = Math.PI;
@Benchmark
public double measureWrong_1() {
    // 值被预测，不执行计算
    return Math.log(Math.PI);
}
@Benchmark
public double measureWrong_2() {
    // final类型依旧被优化
    return Math.log(wrongX);
}

@Benchmark
public double measureRight() {
    return Math.log(x);
}
</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用微基准测试框架JMH再测试一遍：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="variable">@Warmup</span>(iterations = <span class="number">5</span>)</span><br><span class="line"><span class="variable">@Measurement</span>(iterations = <span class="number">10</span>, time = <span class="number">5</span>, timeUnit = TimeUnit.SECONDS)</span><br><span class="line"><span class="variable">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="variable">@State</span>(Scope.Benchmark)</span><br><span class="line">public class Test &#123;</span><br><span class="line">    private AtomicInteger atomic;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line">    private int i = 0;</span><br><span class="line">    <span class="variable">@Setup</span></span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        atomic = new AtomicInteger(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Fork</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable">@Threads</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="variable">@Benchmark</span></span><br><span class="line">    public int incrementAtomic() &#123;</span><br><span class="line">        return atomic<span class="selector-class">.incrementAndGet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Fork</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable">@Threads</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="variable">@Benchmark</span></span><br><span class="line">    public int cas() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        <span class="selector-tag">do</span> &#123;</span><br><span class="line">            i = atomic<span class="selector-class">.get</span>();</span><br><span class="line">        &#125; while (!atomic.compareAndSet(i, i + <span class="number">1</span>));</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Fork</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable">@Threads</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="variable">@Benchmark</span></span><br><span class="line">    public int incrementSync() &#123;</span><br><span class="line">        <span class="selector-tag">synchronized</span> (lock) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显式使用compareAndSet性能并不好，至于为什么，文末的讨论能提供一些帮助</span><br><span class="line">Benchmark             Mode  Cnt     Score    Error  Units</span><br><span class="line">Test<span class="selector-class">.cas</span>              avgt   <span class="number">10</span>  <span class="number">1071.773</span> ± <span class="number">21.083</span>  ns/op</span><br><span class="line">Test<span class="selector-class">.incrementAtomic</span>  avgt   <span class="number">10</span>   <span class="number">363.205</span> ±  <span class="number">1.198</span>  ns/op</span><br><span class="line">Test<span class="selector-class">.incrementSync</span>    avgt   <span class="number">10</span>   <span class="number">748.514</span> ±  <span class="number">8.889</span>  ns/op</span><br></pre></td></tr></table></figure>
<p>再给出最早的那个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">5</span>)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">10</span>, time = <span class="number">5</span>, timeUnit = TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASBench</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id=<span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] lockObj;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt;[] locks;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       lockObj = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lockObj.length; i++) &#123;</span><br><span class="line">            lockObj[i] = <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        locks = <span class="keyword">new</span> AtomicReference[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.length; i++) &#123;</span><br><span class="line">            locks[i] = <span class="keyword">new</span> AtomicReference&lt;Integer&gt;(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="meta">@Threads</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = id % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockObj[index]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="meta">@Threads</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cas</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AtomicReference&lt;Integer&gt; lock = locks[id % <span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span> (!lock.compareAndSet(<span class="keyword">null</span>, id)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        lock.compareAndSet(id, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">Benchmark      Mode  Cnt     Score     Error  Units</span><br><span class="line">CASBench.cas   avgt   <span class="number">10</span>  <span class="number">3441.711</span> ± <span class="number">220.316</span>  ns/op</span><br><span class="line">CASBench.sync  avgt   <span class="number">10</span>   <span class="number">796.758</span> ±  <span class="number">26.033</span>  ns/op</span><br></pre></td></tr></table></figure>
<p>从结果中可以看到，文章开头的那个改造并不是一个好的选择。还是菜鸟，关于并发，CAS还是应该去多看看juc的代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简单聊聊异步同步]]></title>
      <url>http://twogoods.github.io/2017/04/27/IO-Model/</url>
      <content type="html"><![CDATA[<p>我们先看一段伪代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = sql.query("<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span><span class="string">");//15毫秒</span><br><span class="line">count= sql.query("</span><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span><span class="string">");//10毫秒</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>上面这段代码有两个耗时操作，他们顺序执行，完成需要25毫秒的时间，我们把这样的称为同步阻塞调用。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future=executor.submit<span class="function"><span class="params">(()-&gt;sql.query(<span class="string">"select * from table"</span>))</span>;</span><br><span class="line"><span class="title">future2</span>=<span class="title">executor</span>.<span class="title">submit</span><span class="params">(()-&gt;sql.query(<span class="string">"select * from table"</span>))</span>;</span></span><br></pre></td></tr></table></figure>
<p>我们启用线程池，配合Future，<code>future.get()</code>会阻塞到操作完成，最终两个操作可以从25毫秒缩短到15毫秒，在实习当中不少同事就会把这样的代码叫做异步的，其实没错，但这跟操作系统的IO模型会有一些不同。</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>讲这个前自然要先说说阻塞与非阻塞，异步与同步。</p>
<blockquote>
<p>阻塞与非阻塞关注的是线程的状态，IO操作会不会把当前线程挂起。<br>同步和异步关注的是消息通知机制，调用者需不需要关注这个数据返回。</p>
</blockquote>
<p>以下是4种IO模型:</p>
<p><img src="http://oepm97cib.bkt.clouddn.com/io1.gif" alt=""><br><img src="http://oepm97cib.bkt.clouddn.com/io2.gif" alt=""><br><img src="http://oepm97cib.bkt.clouddn.com/io3.gif" alt=""><br><img src="http://oepm97cib.bkt.clouddn.com/io4.gif" alt=""></p>
<p>IO多路复用的一个好处就是以前多个用户线程的阻塞变为了一个线程上的阻塞，单个线程就可以同时处理多个网络连接的IO以支持大量的并发.虽然I/O多路复用的函数也是阻塞的，但I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。我们的NIO是同步非阻塞的，在IO多路复用那张图上我们看到我们还是主动发起系统调用将数据从内核拷贝到用户空间，这里就说明是同步的，此时的用户线程没有挂起。</p>
<p>推荐阅读:<br><a href="https://www.zhihu.com/question/27991975" target="_blank" rel="external">nio是同步非阻塞IO</a><br><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">同步异步阻塞非阻塞</a><br><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="external">io模型</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql笔记]]></title>
      <url>http://twogoods.github.io/2017/04/11/mysql/</url>
      <content type="html"><![CDATA[<p>这两天在看大家都挺推荐的《Mysql技术内幕InnoDB存储引擎》以及其他几本相关的书中对锁，事务，sql调优的章节，对mysql有了更多的理解，零零散散的记一些。<a id="more"></a></p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>innodb按主键的顺序组织表，即按b+树组织。聚焦索引（可以简单理解为主键）；辅助索引，其叶子节点并不包含行记录的全部数据，叶子结点除了包含键值以外，每个叶子结点中的索引行还包含了一个书签，该书签用来告诉存储引擎可以在哪找到相应的数据行。一般情况下一条sql只能使用一个索引，多个优化器也只会选择最优的那个。</p>
<ul>
<li><strong>主键</strong>：非空的唯一索引，innodb里不指定也会自动生成一个6字节大小的指针。</li>
<li><strong>联合索引</strong>:会按索引字段的前后进行排序和索引，因此注意索引字段的顺序，如索引（A，B，C）<code>where A=? and B=? and C=?</code>可以利用索引，而<code>where B=? and C=?</code>无法利用，并且联合索引对于排序也有好处：<code>where A=? and B=? order by C</code>一样可以利用这个索引。<code>group by</code>的优化也类似。</li>
<li><strong>索引覆盖</strong>，简单理解就是你的select字段就是索引，那么就用到了索引覆盖。如<code>select id from T where name=&#39;twogoods&#39;</code>若<code>name</code>字段上有索引，我们的查询会走索引，在这个索引的叶子节点并不包含所有节点，但包含了找到具体数据的主键信息，这里我们只需要得到主键，因此这个索引的叶子节点上就已经提供了，无需去查找具体的数据行。对于索引覆盖形象点得说法是：我要在书里找一个内容，但是书的目录写的很详细，我通过书就找到了，那就无需去翻到具体的页查看了。</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>首先关于乐观锁，悲观锁，名字本身很形象了。乐观锁很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。悲观锁很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。我们不显示指定事务时一条sql也是一个事务，一般来说锁是在整个事务执行完被释放，当然也可能因为不同的隔离级别而有所不同。<br>Innodb是行级锁，S Lock(共享锁)：允许事务读一行数据；X Lock(排他锁)：允许删除更新记录；S与X互斥，S与S兼容，X与X互斥。</p>
<ul>
<li>一致性非锁定读：通过多版本的方式来读取当前执行时间数据库中的数据。正在读取的行被执行update时不等行上锁的释放依然可以操作。</li>
<li>一致性锁定读：innodb默认的隔离级别是可重复读，select 时使用一致性非锁定读。如果读时不允许写需要显试加锁：<code>select ... for update</code> 这样对该行加X锁，其他事务对该行的读或写都阻塞；<code>select lock in share mode</code>加S锁，可以同时读，无法写。</li>
</ul>
<p>个人理解这两种方式就是乐观锁、悲观锁的具体实现；乐观锁在写时不加锁多个线程都可以写，有点像java数据结构里copyonwrite的机制。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul>
<li>tingyint 1个字节，-128~127；int 4字节 ；bigint8字节；注意取值范围合理选用。</li>
<li>datatime 8字节，timestamp 4字节，两者都精确到秒，考虑优先使用timestamp。</li>
<li>varchar 根据需要制定合适的长度，若在此字段上加索引，也注意要索引的长度，长20的索引区分度就能达到90%。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><strong>类型转换</strong>：字段是int的sql中可以使用String来查，只不过mysql帮我们做类型转换而已。</li>
<li><strong>like</strong>：由于b+树索引的结构，<code>like &quot;%a%&quot;</code>是无法通过索引查找的即不能左模糊，<code>like &quot;a%&quot;</code>是可以利用上索引的。不推荐使用<code>like</code>关键字，mysql也提供了全文检索的功能，对中文检索支持并不好，这里有一个中文检索<a href="http://mysqlserverteam.com/innodb%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%EF%BC%9An-gram-parser/" target="_blank" rel="external">插件</a>，不过感觉要上全文索引，好像都直接上搜索引擎了吧…</li>
<li><strong>limit</strong>：mysql offset并不会真正跳过这么多行，可以先快速定位获取id：<code>select * from T a,(select id from T limit 10000,20)b where a.id=b.id</code></li>
<li><strong>count</strong>：注意count(*)会统计该行为null的，count(列名)不会统计null；有时候也可以考虑count(辅助索引列)来加快查询。</li>
<li><strong>in</strong>：in里不要有太多的数据，如<code>id in (select id form T)</code>，我当初还犯过很二的错误，in里需要的数据在另一个数据库里来，没办法写到一个sql里，我查了几十万的id如果在sql里使用in，没多久程序就OOM了-_-……</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java反射的一点总结]]></title>
      <url>http://twogoods.github.io/2017/04/05/reflection/</url>
      <content type="html"><![CDATA[<p>平时写业务一般是用不到反射的，但是框架内部会有非常多的反射，像Spring这一类。自己也去尝试实现过一个简单的框架，也有非常多的反射代码，反射跟普通的对象创建方法调用不同，在性能上不如前者，今天尝试着了解一下反射如何进行优化。<a id="more"></a>在我有限的认识里，主要两点:</p>
<ol>
<li>Class,Method,Field对象缓存。这一点好理解，这些对象的获取都是比较耗时的，不要每次使用都去获取一遍。</li>
<li>使用动态字节码技术，如cglib，它生成的代理类实际是被代理类的子类，在子类中调用父类的方法。<br>为了验证cglib能快多少我简单的写了个测试,环境是jdk8：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SampleBean &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> echo(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        测试代码：</span><br><span class="line">        FastClass fastClass = FastClass.create(SampleBean.<span class="keyword">class</span>);</span><br><span class="line">        FastMethod fastMethod = fastClass.getMethod(SampleBean.<span class="keyword">class</span>.getMethod(<span class="string">"echo"</span>, <span class="keyword">String</span>.<span class="keyword">class</span>));</span><br><span class="line">        SampleBean myBean = new SampleBean();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            fastMethod.invoke(myBean, new Object[]&#123;<span class="string">"haha"</span>+i&#125;);</span><br><span class="line">            <span class="comment">//fastMethod.invoke(myBean, new Object[]&#123;"haha"&#125;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"fastmethod:"</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        Method m = SampleBean.<span class="keyword">class</span>.getMethod(<span class="string">"echo"</span>, <span class="keyword">String</span>.<span class="keyword">class</span>);</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            m.invoke(myBean, <span class="string">"haha"</span>+i);</span><br><span class="line">            <span class="comment">//m.invoke(myBean, "haha");</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"reflect:"</span>+(System.currentTimeMillis() - start));</span><br><span class="line">        </span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            myBean.echo(<span class="string">"haha"</span>+i);</span><br><span class="line">            <span class="comment">//myBean.echo("haha");</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"normal:"</span>+(System.currentTimeMillis() - start));</span><br></pre></td></tr></table></figure>
<p>输出很有意思：fastmethod:196 &gt; reflect:139 &gt; normal:72,cglib是最慢的？！！！如果使用注释的代码跑，fastmethod:38 &gt; reflect:33 &gt; normal:25,时间省了很多但三者的大小顺序没变，时间变少我猜测是百万次调用的参数不变被优化了。<br>于是我怀疑我的测试代码是不是有问题，在网上看了一通发现Java的benchmark是不容易做的，要剔除无关的操作，还要做好JVM的JIT预热，而且有多种gc算法。所以上述所谓的性能测试就是扯淡，不靠谱的…<br>而对于我颇感意外的cglib不如Java自身反射api快的结论，在cglib的文档上也能看到一点端倪：</p>
<blockquote>
<p>However, the newer versions of the HotSpot JVM (and probably many other modern JVMs) know a concept called inflation where the JVM will translate reflective method calls into native version’s of FastClass when a reflective method is executed often enough.  I would therefore recommend to not use FastClass on modern JVMs, it can however fine-tune performance on older Java virtual machines.</p>
</blockquote>
<p>最后，关于Java的benchmark在<a href="http://stackoverflow.com/questions/504103/how-do-i-write-a-correct-micro-benchmark-in-java" target="_blank" rel="external">stackoverflow</a>上有一个讨论; 各个字节码框架与Java自身的反射的性能<a href="https://github.com/neoremind/dynamic-proxy" target="_blank" rel="external">对比</a>,可以参考。结论就是在高版本的Java中反射的性能其实已经挺不错了！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jar包中内容的读取]]></title>
      <url>http://twogoods.github.io/2017/04/01/jar/</url>
      <content type="html"><![CDATA[<p>最近几天有空在折腾<a href="https://github.com/twogoods/tiny4j" target="_blank" rel="external">tiny4j</a>里一直想试着实现的类似springboot的可执行jar包。在<code>component-scan</code>包扫描这一步碰上点小问题，记录一下。<br>项目的<code>Bean</code>都是基于<code>component-scan</code>扫描得到的，要实现这个功能首先根据配置的包名查找的资源路径，这一点可以通过类加载器来得到,它可以在运行时动态的获取加载的类的信息<code>class.getClass().getResource(packageName);</code>这个函数返回一个迭代URL。<a id="more"></a><br>这时如果我们通过<code>java -jar XXX.jar</code>来运行，返回的URL会是类似这样的<code>/Users/xxx/IdeaProjects/web/target/web.jar!/classes/rest.jar/com/tg</code>。jar包是一个文件，文件内部的一些信息没办法直接通过文件API得到，我们可以通过<code>JarFile</code>来得到</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JarFile </span>localJarFile = new <span class="keyword">JarFile(new </span>File(<span class="string">"/Users/xxx/IdeaProjects/abc/web/target/web.jar"</span>))<span class="comment">;</span></span><br><span class="line">Enumeration&lt;<span class="keyword">JarEntry&gt; </span>entries = localJarFile.entries()<span class="comment">;</span></span><br><span class="line">        while (entries.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">JarEntry </span><span class="keyword">jarEntry </span>= entries.nextElement()<span class="comment">;</span></span><br><span class="line">            System.out.println(<span class="keyword">jarEntry.getName());</span><br><span class="line"></span>        &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要扫描的类在jar包里的jar包里该怎么办呢？如这个URL <code>/Users/xxx/IdeaProjects/web/target/web.jar!/BOOT-INF/lib/rest.jar/com/tg</code>,这个形式在可执行Jar里是很正常的，lib目录下是一些依赖的jar。然而上述方法已经得不到这个路径中<code>rest.jar</code>里的内容了。可能这个问题不是很常见，网上找了一圈也没找到解决方法，遂跑去看了一下Spring的实现。在Spring的<code>PathMatchingResourcePatternResolver</code>看到了关键的一个方法</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;Resource&gt; doFindPathMatchingJarResources(Resource rootDirResource, String <span class="keyword">subPattern) </span>throws IOException &#123;</span><br><span class="line">       URLConnection con = rootDirResource.getURL().openConnection()<span class="comment">;</span></span><br><span class="line">       <span class="keyword">boolean </span>newJarFile = false<span class="comment">;</span></span><br><span class="line">       <span class="keyword">JarFile </span><span class="keyword">jarFile;</span><br><span class="line"></span>       String <span class="keyword">jarFileUrl;</span><br><span class="line"></span>       String rootEntryPath<span class="comment">;</span></span><br><span class="line">       if(con <span class="keyword">instanceof </span><span class="keyword">JarURLConnection) </span>&#123;</span><br><span class="line">           <span class="keyword">JarURLConnection </span>result = (<span class="keyword">JarURLConnection)con;</span><br><span class="line"></span>           ResourceUtils.useCachesIfNecessary(result)<span class="comment">;</span></span><br><span class="line">           <span class="keyword">jarFile </span>= result.getJarFile()<span class="comment">;</span></span><br><span class="line">           <span class="keyword">jarFileUrl </span>= result.getJarFileURL().toExternalForm()<span class="comment">;</span></span><br><span class="line">           <span class="keyword">JarEntry </span>entries = result.getJarEntry()<span class="comment">;</span></span><br><span class="line">           rootEntryPath = entries != null?entries.getName():<span class="string">""</span><span class="comment">;</span></span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           String result1 = rootDirResource.getURL().getFile()<span class="comment">;</span></span><br><span class="line">           int entries1 = result1.indexOf(<span class="string">"!/"</span>)<span class="comment">;</span></span><br><span class="line">           if(entries1 != -<span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">jarFileUrl </span>= result1.<span class="keyword">substring(0, </span>entries1)<span class="comment">;</span></span><br><span class="line">               rootEntryPath = result1.<span class="keyword">substring(entries1 </span>+ <span class="string">"!/"</span>.length())<span class="comment">;</span></span><br><span class="line">               <span class="keyword">jarFile </span>= this.getJarFile(<span class="keyword">jarFileUrl);</span><br><span class="line"></span>           &#125; else &#123;</span><br><span class="line">               <span class="keyword">jarFile </span>= new <span class="keyword">JarFile(result1);</span><br><span class="line"></span>               <span class="keyword">jarFileUrl </span>= result1<span class="comment">;</span></span><br><span class="line">               rootEntryPath = <span class="string">""</span><span class="comment">;</span></span><br><span class="line">           &#125;</span><br><span class="line">           newJarFile = true<span class="comment">;</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       LinkedHashSet entries3<span class="comment">;</span></span><br><span class="line">       try &#123;</span><br><span class="line">           if(logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Looking for matching resources in jar file ["</span> + <span class="keyword">jarFileUrl </span>+ <span class="string">"]"</span>)<span class="comment">;</span></span><br><span class="line">           &#125;</span><br><span class="line">           if(!<span class="string">""</span>.equals(rootEntryPath) &amp;&amp; !rootEntryPath.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">               rootEntryPath = rootEntryPath + <span class="string">"/"</span><span class="comment">;</span></span><br><span class="line">           &#125;</span><br><span class="line">           LinkedHashSet result2 = new LinkedHashSet(<span class="number">8</span>)<span class="comment">;</span></span><br><span class="line">           Enumeration entries2 = <span class="keyword">jarFile.entries();</span><br><span class="line"></span>           while(entries2.hasMoreElements()) &#123;</span><br><span class="line">               <span class="keyword">JarEntry </span>entry = (<span class="keyword">JarEntry)entries2.nextElement();</span><br><span class="line"></span>               String entryPath = entry.getName()<span class="comment">;</span></span><br><span class="line">               if(entryPath.startsWith(rootEntryPath)) &#123;</span><br><span class="line">                   String relativePath = entryPath.<span class="keyword">substring(rootEntryPath.length());</span><br><span class="line"></span>                   if(this.getPathMatcher().match(<span class="keyword">subPattern, </span>relativePath)) &#123;</span><br><span class="line">                       result2.<span class="keyword">add(rootDirResource.createRelative(relativePath));</span><br><span class="line"></span>                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           entries3 = result2<span class="comment">;</span></span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if(newJarFile) &#123;</span><br><span class="line">               <span class="keyword">jarFile.close();</span><br><span class="line"></span>           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       return entries3<span class="comment">;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法里的一些对jar的操作其实跟最上的那段代码差不多，在简单调试后我发现Spring的这段代码也是无法实现读取第二层jar包的。这是Spring里的实现，并非SpringBoot<code>@ComponentScan</code>注解的实现，我们传统的Spring项目还是通过war包的方式部署，虽然war包里也有lib目录，看似确实是有两层jar，但在把war部署到servlet容器的时候，其实容器帮我们做了一次解压操作，于是这个场景下就只有一层jar了，或许这就能解释为什么spring上述实现依旧可以正常运行。<br>当然，最终我还是在网上找到了读取多层jar的方法:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(<span class="string">"jar"</span>, null, <span class="number">0</span>, <span class="string">"file:/Users/xxx/IdeaProjects/web/target/web.jar!/BOOT-INF/lib/rest.jar"</span>)<span class="comment">;</span></span><br><span class="line">        URLConnection con = url.openConnection()<span class="comment">;</span></span><br><span class="line">        if (con <span class="keyword">instanceof </span><span class="keyword">JarURLConnection) </span>&#123;</span><br><span class="line">            <span class="keyword">JarURLConnection </span>result = (<span class="keyword">JarURLConnection) </span>con<span class="comment">;</span></span><br><span class="line">            <span class="keyword">JarInputStream </span><span class="keyword">jarInputStream </span>= new <span class="keyword">JarInputStream(result.getInputStream());</span><br><span class="line"></span>            <span class="keyword">JarEntry </span>entry<span class="comment">;</span></span><br><span class="line">            while ((entry = <span class="keyword">jarInputStream.getNextJarEntry()) </span>!= null) &#123;</span><br><span class="line">                System.out.println(entry.getName())<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker]]></title>
      <url>http://twogoods.github.io/2017/02/25/docker/</url>
      <content type="html"><![CDATA[<p>折腾下docker，由于是Mac，安装非常得简单，下载dmg直接安装就行。docker一些基本的概念image，container也都好理解，跑一下nginx，熟悉一下命令行，也算是完成了helloworld了。镜像pull很慢，可以使用<a href="https://www.daocloud.io/" target="_blank" rel="external">daocloud</a>的镜像。<a id="more"></a>  </p>
<p>接下来看看自己写的Java程序怎么build一个镜像.SpringBoot其实官方就有<a href="http://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="external">文档</a>，也非常的简单，用的maven插件spotify。自己在打包的时候报了个500错误，还找了好一会儿，结果发现自己二了，<code>dockerfile</code>写成了<code>dockfile</code>，丢人了(捂脸)…找错误的时候也发现maven里<code>imageName</code>不要出现大写否则会出错。一条基本的启动命令:<br><code>docker run -e &quot;SPRING_PROFILES_ACTIVE=dev&quot; -p 9002:9001 --name book-dev -t bookplatform</code><br><code>docker logs {containername}</code>可以查看日志，不过感觉这种方式不好，当然也可以把日志挂载到本地的目录方便查看，当然这一块的最佳实践还是去看看人家生产环境的经验分享比较好。既然是虚拟机当然也可以进入终端了<code>docker exec -i -t {containername} /bin/sh</code>  </p>
<p>以上都挺简单的，<code>dockerfile</code>要多写写，docker算是开了个头。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HelloRPC]]></title>
      <url>http://twogoods.github.io/2017/02/22/hellorpc/</url>
      <content type="html"><![CDATA[<p>在学校里总要拿点什么东西练练手，看了些文章像什么《从零开始写Rpc》，《从零开始写搜索引擎》都是可以一试的。其实前些日子的<a href="https://github.com/twogoods/tiny4j" target="_blank" rel="external">tiny4j</a>还有些要改进继续完善的东西，奈何人都是喜新厌旧的，总忍不住再开一坑，所以这次是RPC。<a id="more"></a>  </p>
<p>在开始写之前做了不少准备，了解RPC的一些基本的东西，也找了一些RPC框架在试用，诸如GRPC，thrift，它们都提供跨语言调用的能力，根据写的一些配置便可自动生成一些代码。除了这两个国产框架里也有非常优秀的如阿里开源的dubbo，微博的motan；微博的motan文档很简洁，而且直接支持Springboot的注解形式。马上尝试了一下helloworld，大呼过瘾！不考虑跨语言，对于特定的Java，它的Api设计其简单方便，几个注解搞定所有服务，对于Java，这就是我想要的RPC！代码clone下来一看，传输层用的是netty，为了能够完成这个又跑去搞了本《netty 权威指南》啃了大半本，算是入了个门。  </p>
<p>准备工作差不多了于是开始尝试写，毕竟是第一次写，就不考虑跨语言了，像motan一样配合Spring使用能顺手简单就行。简单梳理的整个RPC调用过程，可以分成以下几层：<br><img src="http://i1.piimg.com/4851/71a40fa8d3564fbf.png" alt="rpc层次"><br>通信包括连接建立、消息传输， 编解码要传输的内容，序列化和反序列化，最后是客户端和服务端的实现，客户调用一个服务的代理实现，发起对服务端的请求。  </p>
<p>基于netty5.0，protostuff、kryo序列化库，commons-pool2实现连接池，服务代理使用jdk自身的Proxy或Cglib，在这样一堆优秀的框架和类库上，整个RPC的构建就简单了不少。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>贴一段与Springboot整合的代码，完整的在<a href="https://github.com/twogoods/HelloRpc" target="_blank" rel="external">这里</a>。<br>使用<code>@RpcService</code>注解服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">echo</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RpcService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServiceImpl</span> <span class="keyword">implements</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>application.yml</code>配置</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">tgrpc:</span></span><br><span class="line"><span class="symbol">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="symbol">    port:</span> <span class="number">9100</span></span><br><span class="line"><span class="symbol">    maxCapacity:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">    requestTimeoutMillis:</span> <span class="number">8000</span></span><br><span class="line"><span class="symbol">    maxTotal:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">    maxIdle:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">    minIdle:</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">    borrowMaxWaitMillis:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>启动server:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@EnableAutoConfiguration</span></span><br><span class="line"><span class="variable">@EnableRpcServer</span> <span class="comment">//启用Server</span></span><br><span class="line"><span class="variable">@ComponentScan</span>()</span><br><span class="line">public class ServerApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        ApplicationContext applicationContext = SpringApplication<span class="selector-class">.run</span>(ServerApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方使用<code>@RpcReferer</code>注解.</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceCall</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RpcReferer</span></span><br><span class="line">    <span class="keyword">private</span> EchoService echoService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">echo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> echoService.<span class="title">echo</span><span class="params">(s)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动Client发起调用</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@EnableAutoConfiguration</span></span><br><span class="line"><span class="variable">@EnableRpcClient</span> <span class="comment">//启用Client</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.tg.rpc.springsupport.bean.client"</span>&#125;)</span><br><span class="line">public class ClientApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        ApplicationContext applicationContext = SpringApplication<span class="selector-class">.run</span>(ClientApplication.class);</span><br><span class="line">        ServiceCall serviceCall = (ServiceCall) applicationContext<span class="selector-class">.getBean</span>(<span class="string">"serviceCall"</span>);</span><br><span class="line">        System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"echo return :"</span> + serviceCall.echo(<span class="string">"TgRPC"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个的使用非常简单，当然这中间SpringBoot也占了很大的功劳。</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>当然这还没完，还有很多工作需要做：</p>
<ul>
<li>性能优化</li>
<li>服务注册中心</li>
</ul>
<p>毕竟是一个简单的实现，性能优化方面肯定会去做，但这块又要设计很多的内容：对netty深入的理解，做性能测试找到瓶颈再改进，这些对我来说都是第一次需要慢慢来。<br>注册中心这个最近已经在做一些工作了，现在考虑会把consul,zookeeper都实现一遍，zookeeper以前就玩过，consul现在已经上手了，基本的服务注册，健康检查的概念及使用都以清晰，接下来会开始实现。</p>
<p>未完，待续，争取全部搞定来个总结。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tiny4j:一个轻量级的类似Spring的实现]]></title>
      <url>http://twogoods.github.io/2016/12/04/tiny4j/</url>
      <content type="html"><![CDATA[<p>会点java，做点web，基本也就是spring全家桶，所以打算自己折腾一个，实现最基本最常用的一些功能。断断续续地终于完成了大部分自己想要的功能。实际项目中使用或许还不太现实，不过也提供了一个去了解框架实现的一个简单的版本，也让大家有动力有思路自己去实现一个，源码请戳<a href="https://github.com/twogoods/tiny4j" target="_blank" rel="external">github</a>。<a id="more"></a></p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC很大程度借鉴了Spring,简单的使用</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"test.xml"</span>);</span><br><span class="line">ServiceBean serviceBean=(ServiceBean)applicationContext.getBean(<span class="string">"testService"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(serviceBean);</span><br><span class="line">serviceBean.service();</span><br><span class="line"></span><br><span class="line">ServiceBean serviceBean<span class="number">2</span>=(ServiceBean)applicationContext.getBean(<span class="string">"serviceBean"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(serviceBean<span class="number">2</span>);</span><br><span class="line">serviceBean<span class="number">2</span>.service();</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局的容器上下文</span></span><br><span class="line">ApplicationContextHolder holder=applicationContext.getBean(<span class="string">"applicationContextHolder"</span>, ApplicationContextHolder.<span class="keyword">class</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"holder get bean : "</span>+holder.getBean(<span class="string">"serviceBean"</span>));</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/twogoods/tiny4j/tree/master/core" target="_blank" rel="external">IOC详细说明</a></p>
<h3 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h3><p>实现了许多SpringMvc里高频使用的功能和一些针对restful改进的功能</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Api</span>(<span class="string">"/base"</span>)</span><br><span class="line">public class TestController extends BaseController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Value</span>(<span class="string">"$&#123;user.name:test&#125;"</span>)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Inject</span></span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span></span><br><span class="line">    public String index() &#123;</span><br><span class="line">        userService<span class="selector-class">.query</span>();</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span>(mapUrl = <span class="string">"/test/&#123;id&#125;"</span>, method = HttpMethod.GET)</span><br><span class="line">    <span class="variable">@CROS</span>(origins = <span class="string">"www.baidu.com"</span>, methods = &#123;HttpMethod.GET&#125;, maxAge = <span class="string">"3600"</span>)</span><br><span class="line">    public String patgTest(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) String id) &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span>(mapUrl = <span class="string">"/test"</span>, method = HttpMethod.GET)</span><br><span class="line">    <span class="variable">@InterceptorSelect</span>(include = &#123;<span class="string">"aInterceptor"</span>&#125;, exclude = &#123;<span class="string">"bInterceptor"</span>&#125;)</span><br><span class="line">    public String interceptorTest() &#123;</span><br><span class="line">        return "haha";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span>(mapUrl = <span class="string">"/index"</span>)</span><br><span class="line">    <span class="variable">@CROS</span></span><br><span class="line">    public String paramTest(<span class="variable">@RequestParam</span>(<span class="string">"id"</span>) long id, <span class="variable">@RequestParam</span>(<span class="string">"name"</span>) String name) &#123;</span><br><span class="line">        return name + "---" + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RequestMapping</span>(mapUrl = <span class="string">"/user/&#123;id&#125;"</span>, method = HttpMethod.PUT)</span><br><span class="line">    <span class="variable">@CROS</span></span><br><span class="line">    public User insert(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) long id, <span class="variable">@RequestBody</span> User user) &#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着是不是很熟悉-_- <a href="https://github.com/twogoods/tiny4j/tree/master/rest" target="_blank" rel="external">rest详细说明</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于动态代理]]></title>
      <url>http://twogoods.github.io/2016/11/02/proxy/</url>
      <content type="html"><![CDATA[<p>一般的程序不太会用到动态代理，在写库或者框架的时候用的多一些，我呢硬着头皮在试着完成一个类似spring的框架，过程中自然碰到了动态代理的一些小问题。  <a id="more"></a></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line">public class WebAppConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    <span class="variable">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    AuthorizeInterceptor authorizelInterceptor() &#123;</span><br><span class="line">        return new AuthorizeInterceptor(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry<span class="selector-class">.addInterceptor</span>(authorizelInterceptor())</span><br><span class="line">                <span class="selector-class">.addPathPatterns</span>(<span class="string">"/user/**"</span>);</span><br><span class="line">        super<span class="selector-class">.addInterceptors</span>(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我是这么理解这段代码的：@Bean注解的方法里new出来的对象会仍到IOC里，下面调用了上面注解的方法会在IOC里拿出这个Bean。想改变方法的执行，首先想到的是动态代理。  </p>
<ul>
<li>JDK的动态代理，文中例子里下面这个方法addInterceptors()调用authorizelInterceptor()方法，在执行authorizelInterceptor()这个方法的时候是原模原样执行的不会再走一次代理。</li>
<li>Cglib，方法之间调用都会走代理，适合这个例子。</li>
</ul>
<p>解析<code>@Bean</code>最先想到的方法是这样：创建普通Bean一样创建实例，然后调用所有的<code>@Bean</code>注解的方法，方法得到的Bean放入IOC，最后创建一个这个类的代理对象放入IOC，也就是定义的这个Bean的实例在IOC里实际是一个代理对象。(这个方法有问题，像上面这个例子，<code>addInterceptors()</code>会调用<code>authorizelInterceptor()</code>普通对象调用的时候会创建一个<code>AuthorizeInterceptor</code>,<code>authorizelInterceptor()</code>调用的时候又会创建一个)。为解决这个问题，我们可以一开始就创建代理对象，代理对象调用方法的时候，先查看IOC里有没有这个Bean，没有就创建，有就直接返回IOC里的实例，这样就确保一个Bean只产生了一个实例。<br>我们一开始就创建一个这个类的代理对象，又发现这个类注入了一个属性值，方法里也会使用这个属性，而我在查看创建的代理对象的field时发现并没有<code>name</code>这个field，所以没办法直接设置这个值，这时只能调用<code>setter</code>即<code>setName()</code>来赋上值。然而如果我类里没有创建<code>setter</code>那就无法赋值，好在Cglib可以动态的为属性加上<code>setter</code>方法来解决这个问题。<br>最后，以上是我拿到这个问题自己的一些思考，还并没有看过Spring的实现，有时间去了解一下补上spring的实现。</p>
<hr>
<p><a href="https://github.com/twogoods/tiny4j/blob/master/core/src/test/java/com/tg/tiny4j/core/aop/CglibDynamicAopProxyTest.java" target="_blank" rel="external">代码参考</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[golang小玩具]]></title>
      <url>http://twogoods.github.io/2016/10/09/gotoys/</url>
      <content type="html"><![CDATA[<p>趁着十一假期的最后几天，写了个一直以来就想尝试的东西：命令行程序。还记得当初第一个让我非常惊艳的命令行程序<a href="https://github.com/darknessomi/musicbox" target="_blank" rel="external">网易云音乐命令行版</a>，支持快捷键，带歌词简直6的不行。毕竟程序员，平时离不开terminal，加上iTerm和Oh-My-Zsh更是让人爱不释手。<a id="more"></a>  </p>
<p>所以趁着这几天写了个简单的小玩具，会一些go所以继续用go写，实现了快递查询，天气查询的功能。天气已经实现了根据ip自动定位;快递由于要选择公司，希望接下来可以尝试利用按键来选择。</p>
<h3 id="快递查询"><a href="#快递查询" class="headerlink" title="快递查询"></a>快递查询</h3><p><img src="https://raw.githubusercontent.com/twogoods/tgToys/master/express/express.png" alt="快递查询"></p>
<h3 id="天气查询"><a href="#天气查询" class="headerlink" title="天气查询"></a>天气查询</h3><p><img src="https://raw.githubusercontent.com/twogoods/tgToys/master/weather/weather.png" alt="天气查询"><br><a href="https://github.com/twogoods/tgToys" target="_blank" rel="external">项目地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最好的你们]]></title>
      <url>http://twogoods.github.io/2016/06/26/graduate/</url>
      <content type="html"><![CDATA[<p>最好的四年，遇到最好的你们。  </p>
<p>时间很快，列车也到终点站了，老司机们再不舍也得下车了~一个人闭眼冥想以前的一幕幕都很清晰的浮现在眼前，遇到一些有意思的事还能傻傻的笑，遗憾也就不遗憾了。<a id="more"></a></p>
<h3 id="618"><a href="#618" class="headerlink" title="618"></a>618</h3><p><img src="http://oepm97cib.bkt.clouddn.com/DSCN0516.JPG" alt=""></p>
<p>咱在那里算第一次相遇，某人以一个妖娆的姿势躺在床上欢迎我（我当时的第一感受，这货是哪来的→_→简直辣眼睛)。在618的日子里咱没少浪，每到周五临近周末你们又开始解放天性了不是~当然你们当中的几个懒癌患者的生活习惯哥哥实在是看不下去，到了大二分寝室，我也只能眼睁睁的看着你们生活在水深火热之中。好在分了寝室也没影响咱的交情，该扯淡扯淡，该聊段子还得接着聊，该涮的还是拿某人开涮，只是某人再也不要喝二锅头罢了…但愿你们都不带遗憾的离开。</p>
<h3 id="1203"><a href="#1203" class="headerlink" title="1203"></a>1203</h3><p><img src="http://oepm97cib.bkt.clouddn.com/DSC_6328.jpg" alt=""></p>
<p>咱们班有五个大美女，剩下的都得管着叫爷，光好帅就俩，牛逼的班级你不服不行啊~近30个人，自然无法面面俱到，但遇到过就很好。毕业典礼那天，我把自己人生的第一次通宵奉献给了你们，我第一次看到了班级女生多愁善感的时候，姑娘间那种感情，那种舍不得看得我也有说不出的味道。今天你们中的大部分人都离开学校了，能说再见的我一定不保留，我会再呆几天，争取把你们都送走了我再走。聚是一盆火，散做满天星，天涯海角各奔东西。或许以后你们就是我只能在朋友圈里见到的面孔了，我祝福大家，同样请大家祝福我。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/af5c6f4agw1f58x0skj2jj21kw12a1kx.jpg" alt=""></p>
<h3 id="51"><a href="#51" class="headerlink" title="51"></a>51</h3><p>近一年来的故事似乎都在这里了，在这里有我从来没见到过的风景，当然还有那群可爱的你们。陆陆续续的来，陆陆续续的走，这就是真实的职场节奏。我一直管自己叫傻逼程序员，然而有人说，你不像普通敲代码的，你很有趣，但愿如此吧。渐渐的你们朋友圈下的评论少了我的踪影，但一个赞就代表了全部。我和你们一样，经历了一年的实习生活，眼瞅着你们修成正果毕业工作，我却迎来了一个假期，心里有点空落落的。不眼红，沉住气，我会回来。</p>
<h3 id="zjut"><a href="#zjut" class="headerlink" title="zjut"></a>zjut</h3><p>上了大学就知道其实没那么多好与坏，四年前如果没有选择工大，或许只是故事中的人变了而已，我依旧会变得像现在的我，依旧对一切都表示不服气。大四一年很少逛工大，临走前也应该再去看看它。北上深杭，四座互联网大城市，我的下一站是魔都，我挺恋旧的，上海离杭州不远，我会常回来，看看生活了四年的地方，这一定不是我与工大的最后一张合影。  </p>
<p><img src="http://oepm97cib.bkt.clouddn.com/P60621-170036.jpg" alt=""></p>
<h3 id="me"><a href="#me" class="headerlink" title="me"></a>me</h3><p>最终还是选择了升学，想去见识见识真正的高山。coder,engineer or scientist? no!no!no! 指不定哪天我摇身一变，额，还是一屌丝…哈哈~~ 我在上海，等大家来！</p>
<p>感谢你们，也感谢那些我从未提起的鲜为人知却又妙不可言的故事，你们就是这四年里来我最棒的体验。<br>下次再见请给我一个大大的拥抱！</p>
<blockquote>
<p>一支穿云箭，千军万马来相见<br>两副忠义胆，刀山火海提命现</p>
</blockquote>
<p>圈子不大，方寸之间，我依旧是傻逼程序员，独爱我的mac和code~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客的私密空间]]></title>
      <url>http://twogoods.github.io/2016/06/15/privateblog/</url>
      <content type="html"><![CDATA[<p>很早就有了搞个博客私密空间的想法，需求来源于自己会写一些个人的感受，总结之类的东西，而这些东西我又不太希望每个人都能看到。我知道你要说，你不想让别人看到干脆就不要放博客里嘛！然而你不懂傻逼程序员在写完一篇博客之后不能放在网上嘚瑟的那种不爽的感觉。so，装X绝对是第一生产力，哈哈~  </p>
<p>一直在实习也就一直没找到时间搞这个，当然最重要的一个原因是，现在这个博客是一个利用hexo生成的静态博客，不太好改造。最终为了风格的统一，页面继续用hexo，配合着用go写了个简单的web server，趁着毕业答辩这段时间折腾了一两天，基本实现了自己想要的功能，页面的导航栏处你就能看到它。</p>
<p>微信是试水很多东西最好的地方，然而个人公众号无法申请认证…→ →我选择狗带。<br>马上就毕业了，good luck~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[profile及配置服务]]></title>
      <url>http://twogoods.github.io/2016/04/05/profile/</url>
      <content type="html"><![CDATA[<p>一套完整的代码肯定有不同的profile，开发环境，测试环境，线上环境；程序需要读取不同的配置文件来完成不同环境的部署。传统的spring项目需要使用<code>PropertyPlaceholderConfigurer</code>来完成不同环境下的读取；springboot则特别方便，对于application.yml,application-test.yml,application-dev.yml,在启动参数里加<code>-Dspring.profiles.active=test</code>就可以按需读取，这也还是从本地的不同文件中读取，spring-cloud也提供了一个cloud-config服务，可以非常简单的实现从云端读取不同的配置文件。</p>
<h3 id="基于XML配置的spring项目"><a href="#基于XML配置的spring项目" class="headerlink" title="基于XML配置的spring项目"></a>基于XML配置的spring项目</h3><p>传统的spring项目application.xml里关于配置文件的配置，这个<code>CloudConfigLoader</code>继承<code>PropertyPlaceholderConfigurer</code>来实现按需读取<a id="more"></a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commonConfigurer"</span> <span class="attr">class</span>=<span class="string">"com.tg.common.configuration.CloudConfigLoader"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath*:testsettings.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath*:basesetting.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"settingkeys"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>managersetting,basesetting<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>看一下CloudConfigLoader类<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CloudConfigLoader</span> <span class="keyword">extends</span> <span class="title">RemoteConfigLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">InputStream</span> getConfigByKey(<span class="type">String</span> key) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">String</span> baseurl = <span class="type">System</span>.getProperty(<span class="string">"configurl"</span>);</span><br><span class="line">        <span class="comment">//profile:production/developer</span></span><br><span class="line">        <span class="comment">//启动加jvm参数：-Dconfigurl=xxx</span></span><br><span class="line">        <span class="comment">//-Dprofile=test(或product)</span></span><br><span class="line">        <span class="type">String</span> profile = <span class="type">System</span>.getProperty(<span class="string">"profile"</span>, <span class="string">"product"</span>);</span><br><span class="line">        <span class="type">String</span> requrl = baseurl;</span><br><span class="line">        <span class="keyword">if</span>(!baseurl.endsWith(<span class="string">"/"</span>))requrl+=<span class="string">"/"</span>;</span><br><span class="line">        requrl = requrl + key + <span class="string">"-"</span> + profile+<span class="string">".properties"</span>;</span><br><span class="line">        logger.info(<span class="string">"远程读取配置文件url："</span> + requrl);</span><br><span class="line">        <span class="type">String</span> result = callUrl(requrl,<span class="literal">null</span>,<span class="string">"GET"</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="type">InputStream</span> in = <span class="keyword">new</span> <span class="type">ByteArrayInputStream</span>(result.getBytes());</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及RemoteConfigLoader<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class RemoteConfigLoader extends PropertyPlaceholderConfigurer&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> settingkeys;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> InputStream getConfigByKey(<span class="keyword">String</span> <span class="built_in">key</span>) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">String</span> baseurl = System.getProperty(<span class="string">"configurl"</span>);</span><br><span class="line">		<span class="keyword">String</span> requrl = baseurl + <span class="string">"?key="</span> + <span class="built_in">key</span>;</span><br><span class="line">		logger.info(<span class="string">"远程读取配置文件url："</span> + requrl);</span><br><span class="line">		<span class="keyword">String</span> json = callUrl(requrl,<span class="keyword">null</span>,<span class="string">"GET"</span>,<span class="string">""</span>);</span><br><span class="line">		InputStream in = <span class="keyword">new</span> ByteArrayInputStream(json.getBytes());</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">String</span> callUrl(<span class="keyword">String</span> url, Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span>,</span><br><span class="line">			<span class="keyword">String</span> method, <span class="keyword">String</span> cookie) &#123;</span><br><span class="line">		<span class="comment">//http请求读取云端文件</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> loadProperties(Properties props) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">super</span>.loadProperties(props);</span><br><span class="line">		<span class="keyword">String</span> configurl = System.getProperty(<span class="string">"configurl"</span>);</span><br><span class="line">		<span class="keyword">if</span> (settingkeys != <span class="keyword">null</span> &amp;&amp; configurl != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">String</span> [] keyarr = settingkeys.<span class="built_in">split</span>(<span class="string">","</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span> : keyarr)&#123;</span><br><span class="line">				InputStream in = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					in = getConfigByKey(<span class="built_in">key</span>);</span><br><span class="line">					props.load(in);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					logger.error(<span class="string">""</span>,e);</span><br><span class="line">				&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">					IOUtils.closeQuietly(in);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相应的从本地读不同的配置文件,修改getConfigByKey方法<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InputStream getConfigByKey(<span class="built_in">String</span> key) throws Exception &#123;</span><br><span class="line">       <span class="comment">//profile:test/product</span></span><br><span class="line">       <span class="built_in">String</span> profile = System.getProperty(<span class="string">"profile"</span>, <span class="string">"product"</span>);</span><br><span class="line">       <span class="built_in">String</span> configFile = key + <span class="string">"-"</span> + profile+<span class="string">".properties"</span>;</span><br><span class="line">       logger.info(<span class="string">"读取配置文件："</span> + configFile <span class="string">",</span><br><span class="line">               当前环境为："</span>+(<span class="string">"test"</span>.<span class="keyword">equals</span>(profile)?<span class="string">"测试"</span>:<span class="string">"生产"</span>));</span><br><span class="line">       InputStream <span class="keyword">in</span> = <span class="keyword">Thread</span>.currentThread().getContextClassLoader().</span><br><span class="line">               getResourceAsStream(configFile);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">in</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h3><p>springboot中application.yml里配置不同的profiles,如下分development，production<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    profiles:</span> development</span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  contextPath:</span> /demo</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    profiles:</span> production</span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  contextPath:</span> /demo</span><br></pre></td></tr></table></figure></p>
<p>或者分别配置在不同的文件中，application.yml,application-dev.yml,application-test.yml,默认使用application.yml<br>打成jar包后使用命令<code>java -jar -Dspring.profiles.active=dev 51banka.jar</code></p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>Spring Cloud Config 被设计的非常简单，几乎不需要写代码，看官方文档就可以，添加一些spring cloud的pom依赖，这个就不列出来了。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@EnableConfigServer</span></span><br><span class="line"><span class="comment">//EnableConfigServer注解一定要加</span></span><br><span class="line">public class ConfigServiceApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        SpringApplication<span class="selector-class">.run</span>(ConfigServiceApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>resource下有application.yml,bootstrap.yml;这两个的区别是bootstrap.yml里是相对不变的配置，application.yml里是可以根据cloud服务动态变的。bootstrap.yml:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spring:</span></span><br><span class="line"><span class="symbol">  application:</span></span><br><span class="line"><span class="symbol">    name:</span> configService</span><br><span class="line"><span class="symbol">server:</span></span><br><span class="line"><span class="symbol">  port:</span> <span class="number">9999</span></span><br></pre></td></tr></table></figure></p>
<p>而allpication.yml里的配置,使用了git服务，uri下的git仓库存放了不同的配置文件,命名规则：{application}-{profile}.yml<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">spring</span>:</span><br><span class="line">  <span class="attribute">cloud</span>:</span><br><span class="line">    <span class="attribute">config</span>:</span><br><span class="line">      <span class="attribute">server</span>:</span><br><span class="line">        <span class="attribute">git</span>:</span><br><span class="line">          <span class="attribute">uri</span>: <span class="attribute">https</span>:<span class="comment">//git.coding.net/twogoods/ConfigService.git</span></span><br><span class="line">          <span class="attribute">username</span>: xxx</span><br><span class="line">          <span class="attribute">password</span>: yyy</span><br></pre></td></tr></table></figure></p>
<p>文档里除了application和profile外还有一个lable，lable主要是一个版本信息，若使用git做服务，lable就是不同的分支<br>启动这个服务，配置服务是否成功可以通过url查看：<a href="http://localhost:9999/{application}/{profile}[/{label}" target="_blank" rel="external">http://localhost:9999/{application}/{profile}[/{label}</a>]<br>当使用这个配置服务时，可以增加配置<code>spring.cloud.config.uri: http://myconfigserver.com</code>或者启动增加jvm参数<code>-Dspring.cloud.config.profile=test -Dspring.cloud.config.uri=http://127.0.0.1:9999/</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx]]></title>
      <url>http://twogoods.github.io/2016/03/02/nginx/</url>
      <content type="html"><![CDATA[<p>nginx是著名的反向代理服务器，负载均衡利器，利用一些脚本甚至可以实现动态的负载均衡。这里只是记一下入门的helloworld。  </p>
<p>启动nginx ，sudo nginx ;访问localhost:8080 发现已出现nginx的欢迎页面了。<br>配置文件：/usr/local/etc/nginx/nginx.conf<br><a id="more"></a><br>重新加载配置|重启|停止|退出 nginx<br>nginx -s reload|reopen|stop|quit<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">        listen       <span class="number">9001</span>; 监听的端口</span><br><span class="line">        server_name  banka;</span><br><span class="line">        location / &#123;</span><br><span class="line">        	proxy_pass http:<span class="comment">//local_tomcat; 指向upstream</span></span><br><span class="line">            root   html;</span><br><span class="line">            <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream local_tomcat &#123;  <span class="comment">//配了两个服务，weight为比重</span></span><br><span class="line">	    <span class="keyword">server</span> localhost:<span class="number">8080</span> weight=<span class="number">1</span>;  </span><br><span class="line">	    <span class="keyword">server</span> localhost:<span class="number">10000</span> weight=<span class="number">1</span>;  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>多加一个服务名如mi,代理访问localhost:9000/mi/demo，实际访问的是localhost:8080/demo/。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  banka;</span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /mi/ &#123;</span><br><span class="line">    	<span class="attribute">proxy_pass</span> http://localhost:8080/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊体育运动与新的一年]]></title>
      <url>http://twogoods.github.io/2016/02/28/2016-newyear/</url>
      <content type="html"><![CDATA[<p>过了个年，这不又长膘了，哈哈~仔细想想也好久没运动了，从7月正式实习一直到现在都没正儿八经的运动过一场，惭愧惭愧。要不是在家里，电视这种神奇的东西也是看不见的，偶尔翻开CCTV-5看看，才想起来，哟，今年是奥运年了啊。</p>
<h3 id="体育运动"><a href="#体育运动" class="headerlink" title="体育运动"></a>体育运动</h3><blockquote>
<p>体育运动是人类最伟大的发明</p>
</blockquote>
<p><a id="more"></a> 我不知道有没有前人说过这句话，如果没有那自然是最好的，我以后就可以得意的在后面属上我的名字。喜欢体育是从篮球开始的，那是06年，一晃整整10年。还记得初中高中时代特喜欢打篮球，甚至高中就敢翘一些无关紧要的课去打球，然后被班主任抓到办公室罚站，看来哥也年轻过啊，哈哈~  </p>
<p>体育运动最迷人的就是不确定性，你永远不知道下一刻会发生什么，赢家到底是谁。篮球场上的绝杀球总是激动人心的，足球场上完美的脚下技术也让人赏心悦目。多年的看球经历才让我总结出来上面这句话，而对于我们这种平凡人，时常运动健健康康的就好。前年跟好朋友去看了一场绿城跟恒大的比赛，今年我想去现场看一场篮球比赛，哪怕CBA也好。</p>
<h3 id="新的一年"><a href="#新的一年" class="headerlink" title="新的一年"></a>新的一年</h3><blockquote>
<p>有人的地方就有江湖</p>
</blockquote>
<p>最后一个学期，本科就毕业了，不出意外书还是会继续读下去。新的一年还是希望跟同学，好朋友有多一点相处的时间，毕竟有些人可能这辈子都不会再有交集了，当然也期待着接下来遇到一些更牛逼的人。有聚就会有散，聚是一盆火，散是满天星，英雄惜英雄，相忘于江湖。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>四年其实真的挺快的，转眼即逝。新的一年各位身体健康，工作学习顺利，我呢得把当初对体育运动的热情找回来，好好动动身体，锻炼锻炼，身体是革命的本钱啊。有了好身体，革命就得继续下去，人说不忘初心，那就得继续努力啊，傻逼程序员，哈哈~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git flow]]></title>
      <url>http://twogoods.github.io/2016/01/05/git-flow/</url>
      <content type="html"><![CDATA[<p>用过git，那么肯定要碰到gitflow，gitflow个人认为是多人协作下使用git的一个规范，完全就是git操作，不过安装git flow后特定的命令可以帮我们做很多的事情，理解可以参考阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">文章</a>。  </p>
<p>功能开发<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 初始化工作目录(一直回车即可)</span></span><br><span class="line">git flow init </span><br><span class="line"><span class="meta"># 开始创建新的需求分支(这个会从develop分出来，创建新的分支)</span></span><br><span class="line">git flow feature start editimage #这时项目会自动切换 feature/editimage分支</span><br><span class="line"><span class="meta"># 更改部分代码后</span></span><br><span class="line"><span class="meta"># git commit -a -m "修改完了"</span></span><br><span class="line"><span class="meta"># 完成开发分支合并develop(自动完成,只合并到develop，没有合并到master)</span></span><br><span class="line">git flow feature finish editimage</span><br><span class="line"><span class="meta"># 发布到远程开发分支</span></span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>bug修复<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment"># 切换到master分支</span></span><br><span class="line">git checkout <span class="keyword">master</span></span><br><span class="line"><span class="title"># 更新master</span>分支</span><br><span class="line">git pull origin <span class="literal">master</span>（更新<span class="literal">master</span>分支为最新） </span><br><span class="line"><span class="comment">#生成一个hotfix分支(这个从master分支上切出来，不是从develop)</span></span><br><span class="line">git flow hotfix <span class="literal">start</span> hfx     </span><br><span class="line"><span class="comment"># 最终修改完成后，结束hotfix以供发布(修改后的代码会自动合并到master和develop两个分支)</span></span><br><span class="line">git flow hotfix finish hfx</span><br><span class="line">﻿<span class="comment"># 发布最终的master分支和develop分支</span></span><br><span class="line">git push origin <span class="keyword">master</span></span><br><span class="line"><span class="title">git</span> push origin develop</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mybatis中的几个问题]]></title>
      <url>http://twogoods.github.io/2015/12/07/mybatis/</url>
      <content type="html"><![CDATA[<p>公司里用mybatis，写着写着会有几个问题冒出来，终于有空去看了一下源代码。</p>
<ul>
<li>mybatis 方法签名返回list，LinkedList，如何实现不同的list?<br>解：单纯使用mybatis时  <code>List&lt;Object&gt; user = session.selectList(statement);</code>  只能返回list且实际为arraylist<a id="more"></a>
<code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler</code>里<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  public <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">Object</span>&gt;();</span><br><span class="line">    <span class="built_in">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line">    <span class="built_in">List</span>&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">    <span class="built_in">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">      ResultMap resultMap = resultMaps.<span class="keyword">get</span>(resultSetCount);</span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>[] resultSets = mappedStatement.getResulSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping = nextResultMaps.<span class="keyword">get</span>(resultSets[resultSetCount]);</span><br><span class="line">        <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="built_in">String</span> nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw = getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>配合spring时，实际的sqlSession是一个代理，在SqlSessionTemplate能看到sqlSessionProxy这个代理类，并且代理类里有一个实现InvocationHandler的SqlSessionInterceptor。spring读取配置初始化<code>MapperFactoryBean</code>,方法执行完后对返回类型转换。<code>org.apache.ibatis.binding.MapperMethod</code> 里关于方法返回不同类型集合的转换MapperProxy的invoke方法里调mapperMethod.execute()。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(<span class="function"><span class="keyword">method</span>.<span class="title">getDeclaringClass</span>(</span>))) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">method</span>.<span class="title">invoke</span>(</span>this, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private &lt;E&gt; <span class="type">Object</span> executeForMany(<span class="type">SqlSession</span> sqlSession, <span class="type">Object</span>[] args) &#123;</span><br><span class="line">  <span class="type">List</span>&lt;E&gt; <span class="literal">result</span>;</span><br><span class="line">  <span class="type">Object</span> param = <span class="keyword">method</span>.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">method</span>.hasRowBounds()) &#123;</span><br><span class="line">    <span class="type">RowBounds</span> rowBounds = <span class="keyword">method</span>.extractRowBounds(args);</span><br><span class="line">    <span class="literal">result</span> = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="literal">result</span> = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  // issue <span class="comment">#510 Collections &amp; arrays support</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">method</span>.getReturnType().isAssignableFrom(<span class="literal">result</span>.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">method</span>.getReturnType().isArray()) &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToArray(<span class="literal">result</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), <span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>resulttype为map时，map里的泛型<string,object>,<string,string>如何转化？<br>解：配置有 resultType=”java.util.Map” xml配置会组装在类 <code>MappedStatement</code> mybatis 把结果包装成<code>Map&lt;Object,Object&gt;</code></string,string></string,object></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[springboot]]></title>
      <url>http://twogoods.github.io/2015/11/04/springboot/</url>
      <content type="html"><![CDATA[<p><a href="http://www.searchsoa.com.cn/2015soamicroservice/index.html" target="_blank" rel="external">关于微服务</a>及<a href="https://www.gitbook.com/book/qbgbook/spring-boot-reference-guide-zh/details" target="_blank" rel="external">中文文档</a>。这里也有一个关于微服务的<a href="http://dockone.io/article/1066" target="_blank" rel="external">系列文章</a>，写的很不错，值得一读。<a id="more"></a>  </p>
<p>跟着文档可以快速的上手。springboot确实可以快速的构建一个工程，过程中遇到的一个问题就是配置文件，springboot推荐使用<code>.properities</code>或<code>yml</code>两种方式。配置文件中会分别配置测试与生产环境，如下是一个完整的配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#mvn spring-boot:run 时会使用此配置</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="number">51</span>banka:</span><br><span class="line"><span class="attr">    driverClassName:</span> com.mysql.jdbc.Driver</span><br><span class="line"><span class="attr">    url:</span> jdbc:mysql://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3310</span>/test</span><br><span class="line">    username : root</span><br><span class="line">    password :</span><br><span class="line">    initialSize : <span class="number">10</span></span><br><span class="line">    maxActive : <span class="number">10</span></span><br><span class="line">    maxIdle : <span class="number">10</span></span><br><span class="line">    minIdle : <span class="number">10</span></span><br><span class="line"></span><br><span class="line">spring.view.prefix: /WEB-INF/jsp/</span><br><span class="line">spring.view.suffix: .jsp</span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  contextPath:</span> /bankaservice</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#测试环境的配置，打包成jar 使用 java -jar -Dspring.profiles.active=development target/test.jar 启动</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    profiles:</span> development</span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="number">51</span>banka:</span><br><span class="line"><span class="attr">    driverClassName:</span> com.mysql.jdbc.Driver</span><br><span class="line"><span class="attr">    url:</span> jdbc:mysql://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3310</span>/test</span><br><span class="line">    username : root</span><br><span class="line">    password :</span><br><span class="line">    initialSize : <span class="number">10</span></span><br><span class="line">    maxActive : <span class="number">10</span></span><br><span class="line">    maxIdle : <span class="number">10</span></span><br><span class="line">    minIdle : <span class="number">10</span></span><br><span class="line"></span><br><span class="line">spring.view.prefix: /WEB-INF/jsp/</span><br><span class="line">spring.view.suffix: .jsp</span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">  contextPath:</span> /test</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 生产环境</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    profiles:</span> production</span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="number">51</span>banka:</span><br><span class="line"><span class="attr">    driverClassName:</span> com.mysql.jdbc.Driver</span><br><span class="line"><span class="attr">    url:</span> jdbc:mysql://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3310</span>/test</span><br><span class="line">    username : root</span><br><span class="line">    password : </span><br><span class="line">    initialSize : <span class="number">30</span></span><br><span class="line">    maxActive : <span class="number">40</span></span><br><span class="line">    maxIdle : <span class="number">40</span></span><br><span class="line">    minIdle : <span class="number">30</span></span><br><span class="line"></span><br><span class="line">spring.view.prefix: /WEB-INF/jsp/</span><br><span class="line">spring.view.suffix: .jsp</span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  contextPath:</span> /test</span><br></pre></td></tr></table></figure></p>
<p>另文档的这一处:<br> JSP的限制<br>在内嵌的servlet容器中运行一个Spring Boot应用时（并打包成一个可执行的存档archive），容器对JSP的支持有一些限制。</p>
<ul>
<li>tomcat只支持war的打包方式，不支持可执行的jar</li>
<li>内嵌的Jetty目前不支持JSP</li>
<li>Undertow不支持JSP<br>所以为了防坑还是跳过jsp用别的模板吧</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一些整理]]></title>
      <url>http://twogoods.github.io/2015/10/17/%E5%B0%8F%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>看了《java并发编程实战》确实有一些可以梳理，也可以通过jdk的源码得到答案。  </p>
<ul>
<li><p>java voliate关键字与指令重排序  </p>
<p>缓存一致性问题和指令重排序的问题<a href="http://my.oschina.net/chihz/blog/58035" target="_blank" rel="external">解释1</a>,<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">解释2</a></p>
</li>
<li><p>hashmap的<a href="http://www.360doc.com/content/10/0505/19/495229_26234886.shtml" target="_blank" rel="external">实现</a>，<a href="http://www.nowcoder.com/discuss/1808?type=1&amp;order=0&amp;pos=28&amp;page=0" target="_blank" rel="external">另一个</a></p>
</li>
<li><p><a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="external">concurrenthashmap的实现</a></p>
</li>
<li><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="external">copyonwrite</a>,写时复制，读时不加锁，所以读可能是旧值，只保证最终一致性，不能保证数据的实时一致性，适合读多写少的并发场景</li>
<li>java内存泄露：<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person 利用名字，年龄等属性重写了hashcode方法</span></span><br><span class="line">HashSet&lt;Person&gt; hs=<span class="literal">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">Person p=<span class="literal">new</span> Person(<span class="string">"张三"</span>,<span class="number">25</span>);</span><br><span class="line">p.setAge(<span class="number">10</span>);</span><br><span class="line">hs.remove(p);</span><br><span class="line"><span class="comment">//这里会无法删除，修改属性后hashcode变了，也就无法找到并删除这个对象了</span></span><br><span class="line"><span class="comment">//-----或者想下面这样--------</span></span><br><span class="line"><span class="built_in">Map</span> <span class="built_in">map</span> = <span class="literal">new</span> HashMap();</span><br><span class="line"><span class="comment">//key未重写hashcode和equal方法</span></span><br><span class="line"><span class="comment">//直接这样增加的话，没有new Key()的这样引用，永远无法取出来和移除这个键值对</span></span><br><span class="line"><span class="built_in">map</span>.put(<span class="literal">new</span> Key(<span class="string">"key"</span>), <span class="string">"value"</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一个简易的博客]]></title>
      <url>http://twogoods.github.io/2015/08/04/bolg/</url>
      <content type="html"><![CDATA[<p>很不要脸的拿了一大堆轮子造了个不像博客的博客，当然不是你现在看到的这个啦，不管怎样还是花了心思的，所以简单的说一说。<br>这东西是平常有空全凭兴趣搞的，当初主要是想弄个班级的展示页面，发现就一个页面的话也太单调了，想到给一些自定义内容的功能吧，这么一来二去就变成了这个博客。<br>说起来自己主要是搞java的，这活主要还是前端的活，但当初在学的时候一些基本的html,css,js都了解过，虽说不是举步维艰但也确实是不太熟悉。java总是跟企业级开发联系在一起，拿它写似乎也没必要，这不正好也了解过一点node拿来写写简单的逻辑还是可以的，这个博客也就算是自己学node的一个helloworld吧。  </p>
<ul>
<li><a href="http://tgblog.coding.io" target="_blank" rel="external">演示</a></li>
<li><a href="https://github.com/twogoods/tgblog" target="_blank" rel="external">代码</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[跨域请求jsonp]]></title>
      <url>http://twogoods.github.io/2015/07/22/jsonp/</url>
      <content type="html"><![CDATA[<p>一次面试的时候被问到了跨域请求，提到了jsonp但一直没好好去看，今天再一次碰到这个，就好好的了解了一下。<br>这篇文章讲了<a href="http://www.cnblogs.com/yuzhongwusan/archive/2012/12/11/2812849.html" target="_blank" rel="external">原理</a>，而且比较容易懂,推荐一看。<br>jsonp主要是利用<code>&lt;script type=&quot;text/javascript&quot; src=&quot;scripts/jquery.min.js&quot;&gt;&lt;/script&gt;</code><br>中的src可以跨域获取数据，既然是通过script标签的src属性来请求，那么当然jsonp只有get方式的请求喽。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git的基本操作]]></title>
      <url>http://twogoods.github.io/2015/07/02/git/</url>
      <content type="html"><![CDATA[<ol>
<li>设置Git的user name和email：<br><code>$ git config --global user.name &quot;XXX&quot;</code><br><code>$ git config --global user.email &quot;XXX@gmail.com&quot;</code></li>
<li>键入命令：<code>ssh-keygen -t rsa -C &quot;email@email.com&quot;</code><br><code>email@email.com</code>是git账号；</li>
<li>提醒你输入key的名称，输入如<code>id_rsa</code>；</li>
<li>在用户user目录下产生两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>；</li>
<li>用打开id_rsa.pub文件，复制内容，在github.com的网站上到ssh密钥管理页面，添加新公钥，随便取个名字，内容粘贴刚才复制的内容；</li>
</ol>
<p>基本操作：<br>创建     <code>git init</code><br>添加到版本库      <code>git add readme.txt</code><br>提交到本地    <code>git commit -m &quot;fiorst commit&quot;</code><br>版本回退      <code>git reset --hard commit_id（head、head^、head~100）</code><br>查看状态     <code>git status</code><br>克隆        <code>git clone XXXXX</code><br>撤销文件的修改     <code>git checkout -- readme.txt</code><br><a id="more"></a><br>创建分支     <code>git branch &quot;name&quot;</code><br>切换分支        <code>git checkout &quot;name&quot;</code><br>创建分支+切换      <code>git checkout -b &quot;branchname&quot;</code><br>合并某分支到当前分支    <code>git merge &quot;name&quot;</code><br>删除分支        <code>git branch -d &quot;name&quot;</code><br>查看分支       <code>git branch</code><br>查看分支图    <code>git log --graph</code><br>添加远程库    <code>git remote add origin https://git……</code><br>这里也有阮大神的<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">总结</a><br>最后，不忘出处，学git当然要看<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">廖雪峰</a>啦。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis的安装]]></title>
      <url>http://twogoods.github.io/2015/06/28/redis/</url>
      <content type="html"><![CDATA[<p>一个新东西入门总不是那样简单的，从下载，安装到完成helloworld的过程总是要花些时间的，记下来供以后参考。<a id="more"></a> </p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载肯定是去看看<a href="http://redis.io" target="_blank" rel="external">redis</a>官网啦,不过官网却并没有官方的Windows版本，提供了 Microsoft Open Tech团队的贡献的windows版本的<a href="https://github.com/MSOpenTech/redis" target="_blank" rel="external">链接</a>，可以在这里<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="external">下载</a>msi安装包。一些老的博客上的下载地址会指向<a href="https://github.com/dmajkic/redis" target="_blank" rel="external">这个</a>，不过已经很久没维护了，文档也说了正式的应该是上一个Open Tech团队的。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>确定好要下载哪个后，就是安装了，msi安装文件就非常方便，直接安装并且功能添加到了系统服务中。如果是zip版本跟着文档手动的也可以很快的安装，添加服务。安装好后，命令行进入redis目录，使用命令<code>redis-server.exe redis.windows-service.conf</code>开启服务（当然添加了服务也可以去系统服务里打开），接下来就可以做一个简单的测试了<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h <span class="number">192.168</span><span class="number">.7</span><span class="number">.83</span> -p <span class="number">6379</span>  <span class="comment">//连接服务，注意IP</span></span><br><span class="line"><span class="keyword">set</span> name <span class="comment">haha</span>   //添加键值对</span><br><span class="line">get <span class="comment">name</span>        //得到键为<span class="comment">name</span>的值</span><br></pre></td></tr></table></figure></p>
<p>到这来算是把redis装好了。<br>ps:后来到公司用上了高大上的Mac，mac下安装就容易多了，直接brew安装。<br>一些基本的命令，集群的配置在这个翻译好的<a href="http://redisdoc.com/" target="_blank" rel="external">网站</a>上都有。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中IO的异常处理]]></title>
      <url>http://twogoods.github.io/2015/05/08/exceptionmodel/</url>
      <content type="html"><![CDATA[<ol>
<li><p>平时都不太注意异常的处理，随意的try-catch一下，就像这样</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span> / i;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="literal">e</span>) &#123;</span><br><span class="line">	<span class="literal">e</span>.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正在项目中如果就这样异常的信息只打印在了控制台，log上是没有的，一般都会这样</p>
<a id="more"></a>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span> / i;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> ex) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"exception"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try-catch后重新抛出一个异常（当然最好自己定义一个异常类，抛出自己定义的异常），一层一层抛，最后可以统一处理异常。</p>
</li>
<li>io中的异常处理：<br>在涉及java的io时会遇到各种异常的try-catch典型的写法是这样<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">null</span>;</span><br><span class="line">OutputStream output = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	input = <span class="keyword">new</span> FileInputStream(<span class="string">"XXX"</span>);</span><br><span class="line">	output = <span class="keyword">new</span> FileOutputStream(<span class="string">"YYY"</span>);</span><br><span class="line">	<span class="keyword">while</span>(input.<span class="keyword">read</span>(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">		output.<span class="keyword">write</span>(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			output.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于要处理各种异常，代码变的特别丑陋，这里异常处理模板也就是<strong>模板方法</strong>的设计模式就派上用场了<br>模板1：抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamProcessingTemplate</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		InputStream input = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">			doProcess(input);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					input.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(InputStream input)</span></span><br><span class="line">	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来如何使用<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> InputStreamProcessingTemplate()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doProcess</span><span class="params">(InputStream input)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> inChar = input.read();</span><br><span class="line">            <span class="keyword">while</span>(inChar !- <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">//do something with the chars...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.process(<span class="string">"someFile.txt"</span>);</span><br></pre></td></tr></table></figure></p>
<p>模板2：接口方式<br>先统一声明一个处理具体业务代码的接口,流怎么使用都在这里实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamProcessor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理模板<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InputStreamProcessingTemplate2</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">String fileName,</span><br><span class="line">	InputStreamProcessor processor</span>)</span>&#123;</span><br><span class="line">		InputStream input = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">			processor.process(input);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (input != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					input.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体使用传入匿名内部类<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">InputStreamProcessingTemplate2</span><span class="selector-class">.process</span>(<span class="string">"e://1.txt"</span>,</span><br><span class="line">            new InputStreamProcessor() &#123;</span><br><span class="line">			<span class="variable">@Override</span></span><br><span class="line">			public void process(InputStream input)</span><br><span class="line">			throws IOException &#123;</span><br><span class="line">				int data = input<span class="selector-class">.read</span>();</span><br><span class="line">				<span class="selector-tag">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">					System<span class="selector-class">.out</span><span class="selector-class">.println</span>((char) data);</span><br><span class="line">					data = input<span class="selector-class">.read</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样一来我们使得代码就变得比较整洁,当然java这样一来我们使得代码就变得比较整洁，当然从Java7开始，一种新的被称作“try-with-resource”的异常处理机制被引入进来，也可以像这样使用，它会确保流在使用完被正确关闭。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try(FileInputStream <span class="keyword">input</span> = new FileInputStream(<span class="string">"file.txt"</span>)) &#123;</span><br><span class="line">	        int data = <span class="keyword">input</span>.<span class="keyword">read</span>();</span><br><span class="line">	        <span class="keyword">while</span>(data != -1)&#123;</span><br><span class="line">	            System.<span class="keyword">out</span>.<span class="keyword">print</span>((<span class="keyword">char</span>) data);</span><br><span class="line">	            data = <span class="keyword">input</span>.<span class="keyword">read</span>();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125; catch (IOException <span class="keyword">e</span>) &#123;</span><br><span class="line">			<span class="keyword">e</span>.printStackTrace();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node初步]]></title>
      <url>http://twogoods.github.io/2015/04/20/startNode/</url>
      <content type="html"><![CDATA[<p>其实node在去年就接触过了，最近想进一步接触了解一下，发现菜鸟时遇到的问题还是有必要记一下。</p>
<p>全局安装express：<br> <code>npm install -g express</code><br> express 安装好后命令行还不能使用express命令，需安装express-generato包：<br>  <code>npm install -g express-generator</code><br>  启动express：<br>  <code>npm start</code><br>  当修改代码时每次都要重启服务器会很不方便，node有一个小工具supervisor，安装后使用此工具会根据代码的改动自动重新部署。<br>  安装supervisor：<br>  <code>npm -g install supervisor</code><br>在 package.json里有这样的代码<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="string">"start"</span>: <span class="string">"node ./bin/www"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  所以我们可以使用如下命令来启动express：<br><code>supervisor node ./bin/www</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解java中的回调]]></title>
      <url>http://twogoods.github.io/2015/03/12/callback/</url>
      <content type="html"><![CDATA[<p>在《java编程思想》一书中时不时的提到设计模式，书中也出现了回调，在学习的时候经常听到这个词，也有必要真正去弄明白什么叫<strong>回调</strong>？<br><strong>回调</strong>用一句话解释就是，被调用方在被调用时也会调用对方。形象一点说”If you call me, i will call back”。举个生活中简单的例子：有一位老板很忙，他没有时间盯着员工干活，然后他告诉自己的雇员，干完当前这些事情后，告诉他干活的结果。<br>接下来的代码演示了这个过程：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 回调接口,指明用什么方式跟老板汇报，所以老板应该实现这个接口</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CallBackInterface</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>接下来是老板类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">CallBackInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Employee employee;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.employee=employee;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//简单得实现callback</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"老板，做完了"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//发命令让员工做事</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//将CallBackInterface接口告诉了employee</span></span><br><span class="line">		employee.doSomeThing(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Employee employee=<span class="keyword">new</span> Employee();</span><br><span class="line">		Boss boss=<span class="keyword">new</span> Boss(employee);</span><br><span class="line">		boss.doaction();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>员工类，<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Employee</span> &#123;</span><br><span class="line">	<span class="comment">//简单模拟做事的方法，做完执行回调</span></span><br><span class="line">	<span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">doSomeThing</span>(CallBackInterface cb)&#123;</span><br><span class="line">		System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"干活。。"</span>);</span><br><span class="line">		System<span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"干完了！"</span>);</span><br><span class="line">		cb<span class="selector-class">.callback</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      Employee employee=new Employee()<span class="comment">;</span></span><br><span class="line"><span class="keyword">Boss </span><span class="keyword">boss=new </span><span class="keyword">Boss(employee);</span><br><span class="line"></span><span class="keyword">boss.doaction();</span></span><br></pre></td></tr></table></figure></p>
<p>关于回调的作用网上的这段话至少让我有了一定的认识：我们在用框架的时候，一般直接调用框架提供的API就可以了，但回调不同，当框架不能满足需求，我们想让框架来调用自己的类方法，怎么做呢？总不至于去修改框架吧。许多优秀的框架提几乎都供了相关的接口，我们只需要实现相关接口，即可完成了注册，然后在合适的时候让框架来调用我们自己的类，还记不记得我们在使用Struts时，当我们编写Action时，就需要继承Action类，然后实现execute()方法，在execute()方法中写咱们自己的业务逻辑代码，完成对用户请求的处理。由此可以猜测，框架和容器中会提供大量的回调接口，以满足个性化的定制。</p>
<p>如struts2里Action的一个代理类DefaultActionInvocation中的invoke方法<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String invoke() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    String profileKey = <span class="string">"invoke: "</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UtilTimerStack.<span class="keyword">push</span>(profileKey);</span><br><span class="line">        <span class="keyword">if</span> (executed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Action has already executed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//interceptors是包含所有拦截器的集合</span></span><br><span class="line">        <span class="keyword">if</span> (interceptors.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">final</span> InterceptorMapping interceptor</span><br><span class="line">            = interceptors.<span class="keyword">next</span>();</span><br><span class="line">            String interceptorMsg = <span class="string">"interceptor: "</span> + interceptor.getName();</span><br><span class="line">            UtilTimerStack.<span class="keyword">push</span>(interceptorMsg);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            		<span class="comment">//调用拦截器的拦截方法</span></span><br><span class="line">                    resultCode = interceptor.getInterceptor().</span><br><span class="line">                    intercept(DefaultActionInvocation.<span class="keyword">this</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                UtilTimerStack.<span class="keyword">pop</span>(interceptorMsg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultCode = invokeActionOnly();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!executed) &#123;</span><br><span class="line">        <span class="comment">//此处代码略去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        UtilTimerStack.<span class="keyword">pop</span>(profileKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是ModelDrivenInterceptor拦截器的intercept方法<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> intercept(ActionInvocation invocation)</span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">Object</span> action = invocation.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action <span class="keyword">instanceof</span> ModelDriven) &#123;</span><br><span class="line">        ModelDriven modelDriven = (ModelDriven) action;</span><br><span class="line">        ValueStack stack = invocation.getStack();</span><br><span class="line">        <span class="keyword">Object</span> model = modelDriven.getModel();</span><br><span class="line">        <span class="keyword">if</span> (model !=  <span class="keyword">null</span>) &#123;</span><br><span class="line">        	stack.push(model);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (refreshModelBeforeResult) &#123;</span><br><span class="line">            invocation.addPreResultListener(</span><br><span class="line">            <span class="keyword">new</span> RefreshModelBeforeResult(modelDriven, model));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//明显此处是回调</span></span><br><span class="line">    <span class="keyword">return</span> invocation.invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两段代码连起来看就很明确，struts2处理一个请求的时候会调用DefaultActionInvocation的invoke方法，这个方法会执行一个拦截器的intercept方法，由于调用这个方法的时候传入了invocation自身，使得拦截器里可以回调invocation的invoke的方法，也正是反复的回调使得interceptors集合里的所有拦截器都得到执行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[迎接新的一年]]></title>
      <url>http://twogoods.github.io/2015/03/01/chinesenewyear/</url>
      <content type="html"><![CDATA[<p>　　今天是十一，没到十五理论上年还没过完呢，不过对于我们经历了史上最长寒假的大学生来说，年已经结束了。明天是星期一，开学的第一天。<br>　　回家了20天，除了同学聚会，过年走亲访友，每天就是宅在家里。当初还发微博说要在寒假里好好学习一下angular，可惜事与愿违，家里这就不是一个可以好好学习的地方。度过了这20天的隐居生活，回到学校的第一感受就是，哇塞，我们学校好多女生啊，而且都这么漂亮，好吧，我承认已经确实没看到这么多青春靓丽的女生了，单身狗伤不起啊。。。<br>　　这两天网上最火的就是神马duang,白金还是蓝黑，别欺负我们这种眼镜党好不，分明就是白金的。好了，不瞎扯了，印象最深刻的还是昨天柴静的那个纪录片《<a href="http://v.youku.com/v_show/id_XOTAxNTUxNTI0.html" target="_blank" rel="external">穹顶之下 同呼吸共命运</a>》，发人深思，久久不能平静。</p>
<blockquote>
<p>一个人应该这么活着：春天来的时候门开着，风进来，花香进来，颜色进来；有的时候你碰到雨，或者碰到雾的时候，你会忍不住想要往肺里面，深深的呼吸一口气，能感觉到那个碎雨的那个味道，又凛冽又清新。——柴静《穹顶之下》</p>
</blockquote>
<h3 id="关于新的一年"><a href="#关于新的一年" class="headerlink" title="关于新的一年"></a>关于新的一年</h3><p>　　对于新年计划在总结里提到过了，那些就不再重复了，新年有两个棘手的问题，学车，考研。现在的我学车真是腾不出时间，又不想浪费这毕业前的这段的时间，也无非就是想在毕业前多学点，争取毕业了有底气走向社会然而爸妈又希望我读研究生，所以面临的又一个问题就是要不要考研，现在我还是给不出答案，内心还是想现在多努力，不再去参加那样一场所谓的考试。<br>　　无论如何农历新年已经过去了，又一次离家，新的一年，希望一切都好，家人身体健康。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[javascript基础点]]></title>
      <url>http://twogoods.github.io/2015/02/10/2-10-JavaScript/</url>
      <content type="html"><![CDATA[<p>以下是自己学习JavaScript中遇到的问题，网上的这些博文给出了很好的解答，在此一并小计一下。<br>PS:《javascript高级程序设计》值得一读。</p>
<ol>
<li>立即执行函数(function(){…})() 与 (function(){…}()) 的区别？  <a href="http://segmentfault.com/q/1010000000442042" target="_blank" rel="external">解答</a></li>
<li><a href="http://segmentfault.com/blog/nightire/1190000000348228" target="_blank" rel="external">作用域的问题</a>  ，js里只有函数作用域：<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">color</span>=<span class="string">"red"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">在函数作用域内有一个color的局部变量。</span><br><span class="line">若不是这样，alert(color)使浏览器报color is not defined的错误</span><br><span class="line">*/</span></span><br><span class="line">	alert(<span class="built_in">color</span>);</span><br><span class="line">	<span class="built_in">color</span>=<span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是引用外部的全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">color</span>=<span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">change();<span class="comment">// undefined</span></span><br><span class="line">change(<span class="built_in">color</span>);<span class="comment">// red</span></span><br><span class="line">change2();</span><br><span class="line">alert(<span class="built_in">color</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在执行change()时声明了局部变量color但未初始化所以是undefined；执行change(color)时声明并初始化了局部变量所以是red,紧接着<code>color=&quot;blue&quot;</code>修改了局部变量的值.</p>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">关于闭包</a>，说的通俗些闭包就是能够读取其他函数内部变量的函数。这里有进一步的<a href="https://cnodejs.org/topic/5482d05e73dcca8d21292928" target="_blank" rel="external">说明</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初学产品]]></title>
      <url>http://twogoods.github.io/2015/01/22/pm-start/</url>
      <content type="html"><![CDATA[<p>我也不知道我是什么时候知道产品经理这个词的，前不久又在微博上发现了这套视频，把他分享给大家，那么就从这里开始吧。。。  </p>
<h3 id="技术人的产品修练之路-第零讲"><a href="#技术人的产品修练之路-第零讲" class="headerlink" title="技术人的产品修练之路    第零讲"></a>技术人的产品修练之路    第零讲<a id="more"></a></h3><iframe src="http://www.tudou.com/programs/view/html5embed.action?type=0&code=aZQVWpVOEvo&lcode=&resourceId=366570488_06_05_99" allowtransparency="true" allowfullscreen="true" scrolling="no" border="0" frameborder="0" style="width:480px;height:400px;"></iframe>

<h3 id="技术人的产品修练之路-第一讲"><a href="#技术人的产品修练之路-第一讲" class="headerlink" title="技术人的产品修练之路    第一讲"></a>技术人的产品修练之路    第一讲</h3><iframe src="http://www.tudou.com/programs/view/html5embed.action?type=0&code=E50GcNAKMQc&lcode=&resourceId=366570488_06_05_99" allowtransparency="true" allowfullscreen="true" scrolling="no" border="0" frameborder="0" style="width:480px;height:400px;"></iframe>


<h3 id="技术人的产品修练之路-第二讲"><a href="#技术人的产品修练之路-第二讲" class="headerlink" title="技术人的产品修练之路    第二讲"></a>技术人的产品修练之路    第二讲</h3><iframe src="http://www.tudou.com/programs/view/html5embed.action?type=0&code=2gA6cEJddOc&lcode=&resourceId=366570488_06_05_99" allowtransparency="true" allowfullscreen="true" scrolling="no" border="0" frameborder="0" style="width:480px;height:400px;"></iframe>


<h3 id="技术人的产品修练之路-第三讲"><a href="#技术人的产品修练之路-第三讲" class="headerlink" title="技术人的产品修练之路    第三讲"></a>技术人的产品修练之路    第三讲</h3><iframe src="http://www.tudou.com/programs/view/html5embed.action?type=0&code=TymeE_VVdbY&lcode=&resourceId=366570488_06_05_99" allowtransparency="true" allowfullscreen="true" scrolling="no" border="0" frameborder="0" style="width:480px;height:400px;"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为父亲们点赞]]></title>
      <url>http://twogoods.github.io/2015/01/02/2015-1-2/</url>
      <content type="html"><![CDATA[<p>　　今天中午跟好朋友在去食堂的路上，他说昨天他父亲早上八点给他打电话要来看他，当时他还谁在床上呢，说是在杭州打工正好过来看看他，下午一点就走了。我就好奇问：“这么快就走了，那你们都干嘛了？”，我朋友说，“就来看了看我住的情况啊，简单聊了聊，还给我洗衣服了。”<br>　　父亲难得来一趟，看了看孩子，聊了聊家常，帮孩子洗了衣服就走了。其实我很能想象当时那个场景，因为我和我父亲又未尝没有这样的情景出现过，父子间话不多，几句天冷了多穿点衣服就是送别时的全部。你，我，大家都是一样的，习惯了母亲的唠叨，却不知父亲爱的如此深沉，父爱如山，默默的给所有父亲们点个赞。<a id="more"></a><br>　　到这来我又不禁想起前几天的一个新闻，一女学生和父亲去买手机，姑娘执意要买iPhone6，父亲表情很无奈，看这位父亲的穿着并不像特别宽裕的，但最后还是买下了。全程父女两脸上没有一丝笑容。父亲跌坐在旁边发愁，孩子你这么那么不懂事啊！  </p>
<p><img src="http://ww2.sinaimg.cn/bmiddle/af5c6f4agw1enwj5o6bgjj20c80gaabf.jpg" alt="女儿"><br><img src="http://ww3.sinaimg.cn/bmiddle/af5c6f4agw1enwj5o8u91j20c80gawfq.jpg" alt="父亲"></p>
<embed src="http://player.video.qiyi.com/a4d4c96b81346087c45b21169ecd0304/0/0/w_19rse0yl8t.swf-albumId=2988474209-tvId=2988474209-isPurchase=0-cnId=25" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用mybatis的注意点]]></title>
      <url>http://twogoods.github.io/2014/12/30/12-30-mybatis/</url>
      <content type="html"><![CDATA[<ol>
<li>像mybatis,hibernate等等框架大量用到Java的反射，千万要在你的类中定义默认的构造方法</li>
<li>想这样含多个参数的方法 <code>public String[] getUserbh(String deptbh,String banzubh);</code>配置文件中可用0,1等序号或者将参数变成 <code>Map&lt;String,Object&gt; map</code></li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"getUserbh"</span> parameterType=<span class="string">"String"</span> resultType=<span class="string">"String"</span>&gt;</span><br><span class="line">   <span class="keyword">select</span> usergh <span class="keyword">from</span> people <span class="keyword">where</span> deptbh= <span class="meta">#&#123;0&#125; and banzubh= #&#123;1&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>而这样是会报错的<br>(当然你可以用注解的方式让其准确<code>public String[] getUserbh(@Param(&quot;deptbh&quot;)String deptbh,@Param(&quot;banzubh&quot;)String banzubh);</code>)<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"getUserbh"</span> parameterType=<span class="string">"String"</span> resultType=<span class="string">"String"</span>&gt;</span><br><span class="line">  <span class="keyword">select</span> usergh <span class="keyword">from</span> people <span class="keyword">where</span> deptbh= <span class="meta">#&#123;deptbh&#125; and banzubh= #&#123;banzubh&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>错误如下：<br>org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter ‘deptbh’ not found. Available parameters are [0, 1, param1, param2]　　<br>　3. mybatis中的动态SQL使用OGNL 的表达式<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">if</span> test="<span class="built_in">title</span> != null and <span class="built_in">title</span>!=''"&gt;</span><br><span class="line">       AND <span class="built_in">title</span> like #&#123;<span class="built_in">title</span>&#125;</span><br><span class="line">&lt;/<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第一次尝试]]></title>
      <url>http://twogoods.github.io/2014/12/28/2014-12-28/</url>
      <content type="html"><![CDATA[<p>今天搞了一上午的博客，就弄了一点点东西。<br>这里是<a href="http://zipperary.com/" target="_blank" rel="external">教程</a>,当然更<a href="http://ijiaober.github.io/categories/hexo/" target="_blank" rel="external">详细</a>的在这。<br>hexo版本设计之后各模块都拆分出来，除了官网首页里列的一些命令：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-cli -g</span><br><span class="line">hexo init <span class="keyword">blog</span><br><span class="line"></span>cd <span class="keyword">blog</span><br><span class="line"></span>npm <span class="keyword">install</span><br><span class="line"></span>hexo server</span><br></pre></td></tr></table></figure></p>
<p>还需<code>npm install hexo-deployer-git --save</code>安装提交到git的模块</p>
<h4 id="Markdown推荐Mweb，Quiver，作业部落这几个软件-多写就熟悉了"><a href="#Markdown推荐Mweb，Quiver，作业部落这几个软件-多写就熟悉了" class="headerlink" title="Markdown推荐Mweb，Quiver，作业部落这几个软件,多写就熟悉了"></a>Markdown推荐Mweb，Quiver，作业部落这几个软件,多写就熟悉了</h4><p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e85r40u55hj20b40b4q2x.jpg" alt="ok。。。"></p>
]]></content>
    </entry>
    
  
  
</search>

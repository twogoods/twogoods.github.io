title: 一些整理
date: 2015-10-17 20:05:23
categories: java
tags: 小计
---
看了《java并发编程实战》确实有一些可以梳理，也可以通过jdk的源码得到答案。  
- java voliate关键字与指令重排序  

  缓存一致性问题和指令重排序的问题[解释1](http://my.oschina.net/chihz/blog/58035),[解释2](http://www.cnblogs.com/dolphin0520/p/3920373.html)

- hashmap的[实现](http://www.360doc.com/content/10/0505/19/495229_26234886.shtml)，[另一个](http://www.nowcoder.com/discuss/1808?type=1&order=0&pos=28&page=0)

- [concurrenthashmap的实现](http://ifeve.com/concurrenthashmap/)
- [copyonwrite](http://ifeve.com/java-copy-on-write/),写时复制，读时不加锁，所以读可能是旧值，只保证最终一致性，不能保证数据的实时一致性，适合读多写少的并发场景
- java内存泄露：
  ```
  //person 利用名字，年龄等属性重写了hashcode方法
  HashSet<Person> hs=new HashSet<Person>();
  Person p=new Person("张三",25);
  p.setAge(10);
  hs.remove(p);
  //这里会无法删除，修改属性后hashcode变了，也就无法找到并删除这个对象了
  //-----或者想下面这样--------
  Map map = new HashMap();
  //key未重写hashcode和equal方法
  //直接这样增加的话，没有new Key()的这样引用，永远无法取出来和移除这个键值对
  map.put(new Key("key"), "value");
  
  ```